{"config":{"lang":["en"],"separator":"[\\s\\-\\.]","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"React Lua","text":"<p>React Lua is a Lua port of Facebook's React JS UI library.</p> <p>By and large, React's documentation should be able to serve most React Lua users' needs. This documentation site serves as a comprehensive guide to the differences between Roact and React.</p> <p>If you're new to the React Lua library and want to start learning the concepts of React, begin with the React JS documentation.</p> <p>If you want to find out if a React JS feature is present in React Lua (and if there are any differences to be aware of), check out the API Reference.</p> <p>If you're familiar with React JS and want to learn where React Lua differs, start with the Deviations page.</p> <p>And if you want to migrate an existing project from Legacy Roact to React Lua, check out the guide on Migrating From Legacy Roact.</p>"},{"location":"align-files-guide/","title":"Aligning files guide","text":"<p>We are aligning files by going through them module by module.</p>"},{"location":"align-files-guide/#prerequisites","title":"Prerequisites","text":"<p>In this guide we assume that you have the following project cloned inside of the common directory:</p> <ul> <li>js-to-lua repo link</li> <li>checkout <code>main</code> branch</li> <li>react-lua repo link</li> <li>your working branch on top of <code>main</code> branch</li> <li>react repo link</li> <li>checkout <code>v17.0.2</code> tag</li> </ul>"},{"location":"align-files-guide/#tools-installation","title":"Tools installation","text":"<p>First follow the README instructions to set up js-to-lua. The easiest way is to build the tool by running <code>npx nx build convert-js-to-lua</code> (from within <code>js-to-lua</code> directory)</p>"},{"location":"align-files-guide/#aligning-process","title":"Aligning process","text":"<p>I will show you the process based on the <code>react-devtools-shared</code> module. All the commands shown below are to be executed from <code>js-to-lua</code> directory</p> <p>Depending on the size of the module and/or your preference you can either align all the files at once or do it file by file. In order to convert the whole module at once you can run the following command</p> <pre><code>dist/apps/convert-js-to-lua/index.js \\\n  --input ../react/packages/react-devtools-shared/src/**/*.js \\\n  --output ../react-lua/modules/ \\\n  --rootDir ../react/packages \\\n  --plugin=knownImports --plugin=jestGlobals \\\n  --babelTransformConfig babel-flow-transform-react.config.json \\\n  --babelConfig babel-flow.config.json\n</code></pre> <p>This will run the conversion on all the files in the <code>react-devtools-shared</code> which in our case is a bit too much as this module contains a lot of files that haven't been converted yet. That's why for this particular module I chose to go file by file:</p> <pre><code>dist/apps/convert-js-to-lua/index.js \\\n  --input ../react/packages/react-devtools-shared/src/&lt;path_to_a_js_file&gt; \\\n  --output ../react-lua/modules/ \\\n  --rootDir ../react/packages \\\n  --plugin=knownImports --plugin=jestGlobals \\\n  --babelTransformConfig babel-flow-transform-react.config.json \\\n  --babelConfig babel-flow.config.json\n</code></pre> <p>eg.</p> <pre><code>dist/apps/convert-js-to-lua/index.js \\\n  --input ../react/packages/react-devtools-shared/src/utils.js \\\n  --output ../react-lua/modules/ \\\n  --rootDir ../react/packages \\\n  --plugin=knownImports --plugin=jestGlobals \\\n  --babelTransformConfig babel-flow-transform-react.config.json \\\n  --babelConfig babel-flow.config.json\n</code></pre> <p>After we run the automatic conversion the file will contain a lot of changes. Please additionally run <code>stylua module</code> in the react-lua directory to make sure all the files are converted according to the StyLua configuration.</p> <p>Now our job is to capture the deviations that the original code has made and mark them with appropriate <code>ROBLOX deviation START</code> / <code>ROBLOX deviation END</code> comments.</p> <p>There are some special cases which fast-follow treats separately and you don't need to wrap them in a deviation comment:</p> <ul> <li>upstream comment - with the command shown above there is a small issue with part of the upstream comment not being included. In this case we need to add the missing <code>packages/</code> part of the path.   </li> <li>Packages - js-to-lua can't automatically assign a proper path to <code>Packages</code> variable right now. However, fast-follow will treat conflicts resulting from this line separately so there is no need to wrap it with deviation comment.   </li> </ul> <p>We've added a bunch of improvements in js-to-lua to the output code so be mindful that new types might be better left as is straight from the conversion. Also you might encounter a lot of diff when it comes to class conversion. I suggest leaving the class conversion structure as is and only mark deviation inside of the class's methods body.</p> <p>For example the following diff should not be a deviation anymore: </p> <p>And with class conversion the following example shows how js-to-lua handles class \"methods\" which are defined as arrow functions. The body of the function might still need to be marked with deviation blocks but the structure should most probably stay the same</p> <p> </p> <p>As for the actual deviations that need to be marked let's look at the following example. We can see that the call to <code>Boolean.toJSBoolean</code> is unnecessary in this case so we can comment-out that line, wrap it with <code>-- ROBLOX deviation START:</code> and <code>-- ROBLOX deviation END</code> comments and follow the commented out line with the proper implementation.</p> <p> </p> <p>In order to make that process a little bit easier we've created a set of VSCode snippets that you can use - link to snippets section.</p>"},{"location":"align-files-guide/#snippets","title":"Snippets","text":"<p>You can configure your snippets by invoking <code>Snippets: Configure User Snippets</code> command from VSCode's command pallette and choosing <code>.lua</code> extension. Below you can find all of the snippets we've used.</p> <p>In order to use the snippets you should configure a hot key (keyboard shortcut) for <code>Snippets: Insert Snippet</code> action. Then you can just select a piece of code that you need to mark with deviation, press the hot key and choose the appropriate snippet:</p> <ul> <li><code>deviation-block</code> - will comment out the currently selected code, wrap it with deviation START/END comments and insert a duplicated version of the same code for you to tweak</li> <li><code>deviation-block-skipped</code> - will do the same as <code>deviation-block</code> but won't insert a duplicated code as it's meant for blocks of code that should be skipped</li> <li><code>deviation-block-add</code> - will wrap the currently selected block of code with deviation START/END comments and allow you to put an additional code inside. It's intended for some additional blocks of code that were not included in the original conversion. We use a convention of <code>-- ROBLOX deviation START: add &lt;your_description&gt;</code> to easily distinguish added and changes sections</li> <li><code>deviation-start</code> and <code>deviation-end</code> - will only insert a proper deviation start/end comment. We use those to avoid typos.</li> </ul> <p>There are couple more utility snippets for special cases that were occurring more often:</p> <ul> <li><code>deviation-block-type</code> - it will wrap a block with deviation comments, comment out the block and insert a duplicate but change <code>local</code> for <code>type</code>. It's useful when js-to-lua imported locals from a module when it should actually import types</li> <li><code>deviation-line</code> and <code>deviation-line-skipped</code> are similar to their block equivalents but will use the current line instead of selected block of code</li> </ul> <pre><code>{\n    \"Deviation block - start\": {\n        \"prefix\": \"deviation-start\",\n        \"body\": \"-- ROBLOX deviation START: ${0:description}\",\n        \"description\": \"Roblox deviation start marker\"\n    },\n    \"Deviation block - end\": {\n        \"prefix\": \"deviation-end\",\n        \"body\": \"-- ROBLOX deviation END\",\n        \"description\": \"Roblox deviation end marker\"\n    },\n    \"Deviation block\": {\n        \"prefix\": \"deviation-block\",\n        \"body\": [\n            \"-- ROBLOX deviation START: ${0:changed because}\",\n            \"-- ${TM_SELECTED_TEXT/\\n/\\n-- /g}\",\n            \"$TM_SELECTED_TEXT\",\n            \"-- ROBLOX deviation END\"\n        ],\n        \"description\": \"Roblox deviation end marker\",\n    },\n    \"Deviation block - type\": {\n        \"prefix\": \"deviation-block-type\",\n        \"body\": [\n            \"-- ROBLOX deviation START: ${0:import as type instead of local}\",\n            \"-- ${TM_SELECTED_TEXT/\\n/\\n-- /g}\",\n            \"${TM_SELECTED_TEXT/^local /type /gm}\",\n            \"-- ROBLOX deviation END\"\n        ],\n        \"description\": \"Roblox deviation end marker\",\n    },\n    \"Deviation block - add\": {\n        \"prefix\": \"deviation-block-add\",\n        \"body\": [\n            \"-- ROBLOX deviation START: ${0:add some code}\",\n            \"${TM_SELECTED_TEXT}\",\n            \"${1}\",\n            \"-- ROBLOX deviation END\"\n        ],\n        \"description\": \"Roblox deviation end marker\",\n    },\n    \"Deviation block - skip\": {\n        \"prefix\": \"deviation-block-skipped\",\n        \"body\": [\n            \"-- ROBLOX deviation START: ${0:changed because}\",\n            \"-- ${TM_SELECTED_TEXT/\\n/\\n-- /g}\",\n            \"-- ROBLOX deviation END\"\n        ],\n        \"description\": \"Roblox deviation end marker\",\n    },\n    \"Deviation line\": {\n        \"prefix\": \"deviation-line\",\n        \"body\": [\"-- ROBLOX deviation START: ${0:changed because}\", \"-- $TM_CURRENT_LINE\", \"$TM_CURRENT_LINE\", \"-- ROBLOX deviation END\"],\n        \"description\": \"Roblox deviation end marker\"\n    },\n    \"Deviation line - skipped\": {\n        \"prefix\": \"deviation-line-skipped\",\n        \"body\": [\"-- ROBLOX deviation START: ${0:changed because}\", \"-- $TM_CURRENT_LINE\", \"-- ROBLOX deviation END\"],\n        \"description\": \"Roblox deviation end marker\"\n    }\n}\n</code></pre>"},{"location":"bench/","title":"Benchmarks","text":"Last Update: Repository: Download data as JSON Powered by github-action-benchmark"},{"location":"configuration/","title":"Configuration","text":"<p>React can currently be configured by assigning values to a small number of special global variables. Typically, they need to be set up before <code>React</code> or <code>ReactRoblox</code> is initialized via <code>require</code>. There are a couple of ways to do this:</p> <ul> <li>Assign values immediately at the beginning of the entry point script in your project</li> </ul>"},{"location":"configuration/#globals","title":"Globals","text":""},{"location":"configuration/#__dev__","title":"__DEV__","text":"<p>Enabling <code>_G.__DEV__</code> enables \"Dev Mode\", a general-purpose option that sacrifices performance to enable a number of features that improve the development experience:</p> <ul> <li>Component <code>render</code> methods are run twice to ensure that no side-effects are being counted upon</li> <li>Warnings for behavior that violates React rules and best practices, like:<ul> <li>Reading state when it hasn't been initialized</li> <li>Calling <code>setState</code> before a component has mounted</li> <li>Assigning multiple keys to a component</li> <li>Failing to assign keys to elements in a list (a potential de-optimization)</li> </ul> </li> <li>Warnings for the use of deprecated components or features</li> <li>Validation of properties passed into components via <code>validateProps</code> or <code>propTypes</code></li> </ul> <p>You should enable Dev Mode in any or all of the following situations:</p> <ul> <li>Running unit or integration tests</li> <li>Running storybooks</li> <li>Developing and testing locally as you work</li> </ul> <p>Dev Mode is not meant to be enabled on production. While it exposes a great deal of useful information and introduces extra assurances, it pays a hefty performance cost to do so.</p> <p>Info</p> <p>Consider using a tool like darklua to automatically remove all code branches that check for Dev Mode when creating bundles for production. This reduces the overhead of branching on Dev Mode logic and saves a little bit of extra performance in places where it matters.</p>"},{"location":"configuration/#__disable_all_warnings_except_prop_validation__","title":"__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__","text":"<p>Occasionally, some older projects will issue more warnings in Dev Mode than can easily be resolved. In order to introduce prop validation but silence all other Dev Mode warnings, set the <code>__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__</code> global to <code>true</code>.</p> <p>Info</p> <p>Typically, this is only necessary in tests that are strict about reducing warning output. In general, prefer the full-featured Dev Mode.</p>"},{"location":"configuration/#__compat_warnings__","title":"__COMPAT_WARNINGS__","text":"<p>Enables compatibility warnings for any uses of outdated APIs in your code. These compatibility mismatches should have no effect on behavior, but can be modernized to better align to standards and anticipate future releases. Compat warnings will help you surface uses of outdated APIs when you migrate from Roact 1.x.</p>"},{"location":"configuration/#__roact_17_mock_scheduler__","title":"__ROACT_17_MOCK_SCHEDULER__","text":"<p>Ensure that React's internal scheduler is mocked instead of using real async logic like <code>task.delay</code>. This is useful in conjunction with the <code>act</code> function to test concurrent behavior via the \"arrange-act-assert\" pattern.</p> <p>Use this global in test configuration to make sure that you're not inadvertently relying on asynchronous logic in tests. Since React Lua uses concurrent rendering by default, you will always need this global to be set to <code>true</code> (except when using the <code>__ROACT_17_COMPAT_LEGACY_ROOT__</code> global described below).</p> <p>Caution</p> <p>In future updates, React should always mock the scheduler when in a testing environment and avoid extra configuration. For now, React favors explicitness while we shore up the testing experience.</p>"},{"location":"configuration/#__roact_17_inline_act__","title":"__ROACT_17_INLINE_ACT__","text":"<p>This global will automatically wrap the behavior of <code>RoactCompat.mount</code>, <code>RoactCompat.update</code>, and <code>RoactCompat.unmount</code> in <code>ReactRoblox.act</code>, which ensures that queued actions will be played forward by the mocked scheduler.</p> <p>This is intended for tests only, and will not work correctly unless <code>__ROACT_17_MOCK_SCHEDULER__</code> is also enabled.</p>"},{"location":"configuration/#__roact_17_compat_legacy_root__","title":"__ROACT_17_COMPAT_LEGACY_ROOT__","text":"<p>Ensures that the <code>RoactCompat.mount</code> compatibility function creates a Legacy Root instead of a Concurrent Root, which is the default behavior.</p> <p>Use this global to preserve old behavior in certain testing scenarios. If you need to explicitly rely on a legacy root in production, consider opting for the <code>createLegacyRoot</code> API instead.</p>"},{"location":"deviations/","title":"Deviations","text":"<p>While React Lua has been architected to align with React JS's APIs and idioms, a small number of deviations have been introduced for one or several of the following reasons:</p> <ul> <li>Differences between JavaScript and Luau</li> <li>Differences between Roblox and the HTML DOM</li> <li>Supporting features from legacy Roact that are not in React JS</li> <li>Easier adoption of React Lua by users of legacy Roact</li> </ul> <p>The following list attempts to comprehensively describe all of the differences between React Lua and its equivalent upstream version in React JS. It is intended to be a companion to the React Lua adoption guide, which focuses more on the differences between legacy Roact and React Lua.</p>"},{"location":"deviations/#jsx","title":"JSX","text":"<p>The Luau ecosystem does not yet have the tooling to support JSX. Instead, use <code>React.createElement</code> as your primary tool for building UIs with React Lua. Element construction in React Lua is exactly like using React without JSX.</p> <p>Info</p> <p>Future support for a JSX-equivalent feature for Luau has been proposed, and will be considered as React Lua is adopted.</p>"},{"location":"deviations/#reactusestate","title":"<code>React.useState</code>","text":"<p><code>React.useState</code> returns two values rather than an array containing two values.</p> <p>Luau does not have syntactic sugar for destructuring like javascript:</p> <pre><code>const [value, setValue] = React.useState(0);\n</code></pre> <p>However, it does support multiple return values, so we can support a very similar usage:</p> <pre><code>local value, setValue = React.useState(0)\n</code></pre>"},{"location":"deviations/#hook-dependency-arrays","title":"Hook Dependency Arrays","text":""},{"location":"deviations/#dependency-arrays","title":"Dependency Arrays","text":"<p>In React JS, some hooks accept an array of dependency values that determine when they need to be re-invoked:</p> <pre><code>useEffect(() =&gt; {\n  document.title = `You clicked ${count} times`;\n}, [count]); // Only re-run the effect if count changes\n</code></pre> <p>The dependency array should always be specified inline rather than composed dynamically to ensure that it accurately reflects all values relevant to the hook, whatever their state may be during a given render.</p> <p>React JS provides warnings in DEV mode when a dependency array changes length between renders, an indication that the feature isn't being used correctly. It additionally provides a linter plugin that can help enforce these rules and prevent mistakes during development: https://www.npmjs.com/package/eslint-plugin-react-hooks</p>"},{"location":"deviations/#deviations-for-luau","title":"Deviations for Luau","text":"<p>Hooks in React Lua aim to treat dependency arrays exactly like React JS. However, arrays in luau that contain nil-able values might be indistinguishable from similar arrays that simply have different lengths.</p> <p>For example:</p> <pre><code>print(#{\"A\", \"B\", nil} == #{ \"A\", \"B\" }) -- prints: true\n</code></pre> <p>This means that, if we align behavior directly with React JS, we introduce a possible scenario in which a correctly-specified dependency array triggers warnings about differences in length:</p> <pre><code>local root = ReactRoblox.createRoot(someContainer)\nlocal function Component(props: { A: number, B: number? })\n    React.useEffect(function()\n        -- Trigger some effect\n    end, { props.A, props.B })\n\n    return nil\nend\n\n-- does not warn:\nroot:render(React.createElement(Component, { A = 1, B = 2 }))\n-- subsequent render warns about different length arrays:\nroot:render(React.createElement(Component, { A = 1 }))\n</code></pre> <p>To address this and support the same API as React JS, React Lua introduces two minor deviations:</p> <ul> <li>If a dependency array changes in length, a re-render will always be triggered (in React JS, the comparison is short-circuited in production with the assumption that warnings had been ignored or addressed)</li> <li>If a dependency array changes in length, we assume the developer provided an array ending with one or more nil-able values, and we suppress the warning</li> </ul> <p>Hooks affected:</p> <ul> <li><code>useEffect</code></li> <li><code>useLayoutEffect</code></li> <li><code>useMemo</code></li> <li><code>useCallback</code></li> </ul>"},{"location":"deviations/#stable-keys","title":"Stable Keys","text":"<p>In React JS, the reserved \"key\" prop is used to provide stable identities to DOM elements. This improves performance when list-like data is reordered by helping React understand which elements are which, instead of simply modifying the element at each position to line up with the new ordering (more info in the React documentation).</p> <p>Since order has no inherent meaning in Roblox's DOM, legacy Roact generally expected children to be provided as a map instead of an array, where the keys to the map are the stable keys associated with the elements. This behavior was used instead of a reserved \"key\" prop (more info in the Roact documentation).</p> <p>React Lua supports both methods for providing keys. Both of the following examples are valid and equivalent.</p> <p>With table keys:</p> <pre><code>-- Returns a fragment of items in an ordered list\nfunction NumberList(props)\n    local numbers = props.numbers\n    for i, number in numbers do\n        local key = tostring(i)\n        listItems[key] = React.createElement(\"TextLabel\", {\n            Text = key,\n            LayoutOrder = i,\n        })\n    end);\n    return listItems\nend\n</code></pre> <p>Using the special \"key\" prop:</p> <pre><code>-- Returns a fragment of items in an ordered list\nfunction NumberList(props)\n    local numbers = props.numbers\n    for i, number in numbers do\n        local key = tostring(i)\n        local element = React.createElement(\"TextLabel\", {\n            key = key,\n            Text = key,\n            LayoutOrder = i,\n        })\n        table.insert(listItems, element)\n    end);\n    return listItems\nend\n</code></pre> <p>If your component provides keys using both methods at the same time, Roact will consider this a mistake and print a warning. The following code would result in a warning: <pre><code>return React.createElement(\"Frame\", nil, {\n    Label = React.createElement(\"TextLabel\", {\n        key = \"label1\",\n        Text = \"Hello\",\n    })\n})\n</code></pre></p> <p>In the above example, React doesn't know whether you wanted to use \"label1\" or \"Label\" as the key, so it falls back to the explicitly provided key (\"label1\"). In Dev Mode, it will output an appropriate warning as well.</p>"},{"location":"deviations/#class-components","title":"Class Components","text":"<p>Luau does not currently have ES6's <code>class</code> semantics. For class components, Roact exposes an <code>extend</code> method to provide equivalent behavior.</p>"},{"location":"deviations/#reactcomponentextend","title":"<code>React.Component:extend</code>","text":"<pre><code>React.Component:extend(name: string): ReactComponent\n</code></pre> <p>The <code>extend</code> method on components replaces the <code>extend</code> behavior used in ES6's class components. It returns a React component definition, which can then be used to define lifecycle methods.</p> <p>For example, a class component in React Lua can be created like this:</p> <pre><code>local MyComponent = React.Component:extend(\"MyComponent\")\n\nfunction MyComponent:render()\n    return React.createElement(\"TextLabel\", {Text = self.props.text})\nend\n\nfunction MyComponent:componentDidMount()\n    print(\"rendered with text \" .. self.props.text)\nend\n</code></pre> <p>Equivalently, <code>React.PureComponent:extend</code> is used to define PureComponents.</p>"},{"location":"deviations/#constructors","title":"Constructors","text":"<p>Since Luau currently lacks a <code>class</code> feature, there are also no inheritable constructors; instead, React Lua provides a lifecycle method called <code>init</code> that takes the place of the constructor, running immediately after an instance of that class is created.</p> <p>For all intents and purposes, this should behave exactly like a constructor for a class component in React JS, except that there is no <code>super</code> logic needed.</p>"},{"location":"deviations/#calling-setstate-in-constructors","title":"Calling <code>setState</code> in Constructors","text":"<p>In React JS, <code>setState</code> is not allowed inside component constructors. Instead, React documentation suggests that <code>this.state</code> should be assigned to directly, but never anywhere else.</p> <p>Legacy Roact opts to allow <code>setState</code> inside of the <code>init</code> method (equivalent to a constructor), because it allows documentation to consistently warn against assigning directly to <code>self.state</code>. However, for backwards compatibility, it still supports direct assignments to <code>self.state</code> in <code>init</code>.</p>"},{"location":"deviations/#recommended-use","title":"Recommended Use","text":"<p>As with legacy Roact, React Lua allows both direct assignment and use of <code>setState</code>. This allows guidance from legacy Roact documentation and common practice to remain accurate.</p> <p>In React Lua, it is still recommended to use <code>setState</code> inside of component <code>init</code> methods. This means that you will always avoid assigning directly to <code>self.state</code>.</p>"},{"location":"deviations/#behavior","title":"Behavior","text":"<p>When used in a constructor, <code>setState</code> will treat the <code>updater</code> argument exactly as it does elsewhere.</p> <ul> <li>If <code>setState</code> is called multiple times in a constructor, each subsequent update will be merged into previous state</li> <li>The <code>updater</code> argument can be a function that accepts previous state and returns a new table that will be merged into any previous state</li> <li>The <code>updater</code> argument can be a table that will be merged into any previous state</li> </ul> <p>Caution</p> <p>When using <code>setState</code> in a constructor, the optional <code>callback</code> argument will not be used. Instead, consider putting the desired behavior in a <code>componentDidMount</code> implementation.</p>"},{"location":"deviations/#error-boundaries","title":"Error Boundaries","text":"<p>Error boundaries are not yet fully supported due to a limitation in Luau around recursive <code>pcall</code> depth. Future updates to React will unravel the recursive traversal and enable these features.</p>"},{"location":"deviations/#property-validation","title":"Property Validation","text":"<p>The legacy api <code>validateProps</code> is still present and has a backwards-compatible API.</p>"},{"location":"deviations/#function-components","title":"Function Components","text":"<p>In JavaScript, functions are also objects, which means that they can have member fields defined on them. Luau does not allow this, so some features are not available on function components.</p> <p>Info</p> <p>With the introduction of Hooks, function components are the preferred style of component definition. Giving up features like <code>defaultProps</code> and prop validation is not ideal, so future API additions may provide a way to create smarter function components.</p>"},{"location":"deviations/#defaultprops","title":"<code>defaultProps</code>","text":"<p>For the time being, function components do not support the <code>defaultProps</code> feature. In the future, we may want to re-implement it in terms of hooks to make sure that function components with hooks are as appealing and feature-rich as possible.</p>"},{"location":"deviations/#proptypes","title":"<code>propTypes</code>","text":"<p>For the time being, function components do not support the <code>propTypes</code> feature. While propTypes is less often used and can in many cases be superseded by static type checking, we may want to, in the future, re-implement it in terms of hooks to make sure that function components with hooks are as appealing and feature-rich as possible.</p>"},{"location":"deviations/#validateprops","title":"<code>validateProps</code>","text":"<p>In React Lua, we continue to support legacy Roact's <code>validateProps</code>. Prior Roact documentation on this method can be found here.</p>"},{"location":"deviations/#bindings-and-refs","title":"Bindings and Refs","text":"<p>Roact supports callback refs, refs created using <code>React.createRef</code>, and refs using the <code>React.useRef</code> hook. However, under the hood, Refs are built on top of a concept called Bindings.</p>"},{"location":"deviations/#bindings","title":"Bindings","text":"<p>Roact introduces a bindings feature that provides a unidirectional data binding that can be updated outside of the render cycle (much like refs could).</p> <p>For now, bindings are documented in more detail here.</p>"},{"location":"deviations/#host-properties-with-instance-values","title":"Host Properties with Instance Values","text":"<p>The Roblox API exposes certain host properties that must be assigned Instance references as values. Effectively, there are native APIs that expect a <code>ref.current</code> value as a value.</p> <p>The logic of bindings is a perfect fit for this scenario. Consider the following example:</p> <pre><code>local PopupButtons = Roact.Component:extend(\"PopupButtons\")\nfunction PopupButtons:init()\n    self.confirmRef = Roact.createRef()\n    self.cancelRef = Roact.createRef()\nend\nfunction PopupButtons:render()\n    --[[\n            \"Some Description\"\n        [ Confirm ]    [ Cancel ]\n    ]]\n    return Roact.createElement(\"Frame\", nil {\n        ConfirmButton = Roact.createElement(\"TextButton\", {\n            [Roact.Ref] = self.confirmRef,\n            Text = \"Confirm\",\n            NextSelectionRight = self.cancelRef.value,\n        }),\n        CancelButton = Roact.createElement(\"TextButton\", {\n            [Roact.Ref] = self.cancelRef,\n            Text = \"Confirm\",\n            NextSelectionLeft = self.confirmRef.value,\n        }),\n    })\nend\n</code></pre> <p>This example poses a problem. Since children will be rendered in an arbitrary order, one of the following will happen:</p> <ol> <li>Confirm Button renders first and its ref is assigned</li> <li>Confirm Button's NextSelectionRight property is set to the Cancel Button's ref, which is currently nil</li> <li>Cancel Button renders and its ref is assigned</li> <li>Cancel Button's NextSelectionLeft property is properly set to the Confirm Button's ref</li> </ol> <p>Or:</p> <ol> <li>Cancel Button renders first and its ref is assigned</li> <li>Cancel Button's NextSelectionLeft property is set to the Confirm Button's ref, which is currently nil</li> <li>Confirm Button renders and its ref is assigned</li> <li>Confirm Button's NextSelectionRight property is properly set to the Cancel Button's ref</li> </ol> <p>Thus, it would require much more trickery to make even a simple gamepad neighbor assignment work correctly. However with refs implemented as bindings, the above scenario can be solved pretty simply:</p> <pre><code>-- ...\n    return Roact.createElement(\"Frame\", nil {\n        ConfirmButton = Roact.createElement(\"TextButton\", {\n            [Roact.Ref] = self.confirmRef,\n            Text = \"Confirm\",\n            -- pass the ref itself, which is a binding\n            NextSelectionRight = self.cancelRef,\n        }),\n        CancelButton = Roact.createElement(\"TextButton\", {\n            [Roact.Ref] = self.cancelRef,\n            Text = \"Confirm\",\n            -- pass the ref itself, which is a binding\n            NextSelectionLeft = self.confirmRef,\n        }),\n    })\n-- ...\n</code></pre> <p>With the above implementation, something like the following happens:</p> <ol> <li>Confirm Button renders first and its ref is assigned</li> <li>Confirm Button's NextSelectionRight property is set to the Cancel Button's ref, which is currently nil</li> <li>Cancel Button renders and its ref is assigned<ul> <li>The binding value updates, and the Confirm button's NextSelectionRight property is assigned to the Cancel Button's new ref value</li> </ul> </li> <li>Cancel Button's NextSelectionLeft property is properly set to the Confirm Button's ref</li> </ol> <p>...or the inverse, with the Cancel Button rendering first. Either way, both refs are assigned, and both neighbor properties are assigned by the time the render is complete.</p>"},{"location":"api-reference/additional-libraries/","title":"Additional Libraries","text":""},{"location":"api-reference/additional-libraries/#reactis","title":"ReactIs","text":"<p>Under construction \ud83d\udd28</p>"},{"location":"api-reference/additional-libraries/#reacttestrender","title":"ReactTestRender","text":"<p>Under construction \ud83d\udd28</p>"},{"location":"api-reference/additional-libraries/#reactdevtoolsextensions","title":"ReactDevToolsExtensions","text":"<p>Under construction \ud83d\udd28</p>"},{"location":"api-reference/react-roblox/","title":"ReactRoblox","text":"<p>The ReactRoblox package is the entry point for any Roblox-opinionated logic. It can be thought of as the equivalent of the ReactDOM package in React JS.</p> <p>However, rather than fully implementing all of the features of ReactDOM, it leaves most deprecated APIs out entirely, implementing only the modern and forward-looking portions of the API.</p> <p>Notable absences are:</p> <ul> <li><code>render</code> - Use <code>createRoot</code> (or, depending on the circumstances, <code>createBlockingRoot</code> or <code>createLegacyRoot</code>) instead</li> <li><code>unmountComponentAtNode</code> - Use the <code>unmount</code> method on the root object returned from <code>createRoot</code> instead</li> <li><code>findDOMNode</code> - Use refs instead</li> </ul>"},{"location":"api-reference/react-roblox/#reactrobloxcreateroot","title":"<code>ReactRoblox.createRoot</code>","text":"<p>Adopted as part of the Concurrent Mode API. Refer to <code>ReactDOM.createRoot</code> documentation.</p>"},{"location":"api-reference/react-roblox/#reactrobloxcreateblockingroot","title":"<code>ReactRoblox.createBlockingRoot</code>","text":"<p>Adopted as part of the Concurrent Mode API. \"Blocking\" roots represent a transitional step between synchronous rendering and full concurrent rendering. Refer to <code>ReactDOM.createBlockingRoot</code> documentation.</p>"},{"location":"api-reference/react-roblox/#reactrobloxcreatelegacyroot","title":"<code>ReactRoblox.createLegacyRoot</code>","text":"<p>Adopted as part of the Concurrent Mode API. \"Legacy\" roots are essentially equivalent to pre-concurrent React behavior. Refer to <code>ReactDOM.createLegacyRoot</code> documentation.</p>"},{"location":"api-reference/react-roblox/#deviations","title":"Deviations","text":"<p>React documentation provides a handy chart that explains the feature differences between the roots. This table lists three deprecated features under legacy roots only:</p> <ul> <li>String Refs</li> <li>Legacy Context</li> <li>findDOMNode</li> </ul> <p>These features were never implemented in legacy Roact, and have not been ported. Instead, creating a Legacy Mode root simply tells React Lua to render synchronously. This behavior is most similar to legacy Roact or pre-Concurrent-Mode React JS.</p> <p>Generally speaking, <code>ReactRoblox.createRoot</code> should be used for all new work, while the Blocking and Legacy versions can be used for upgrading existing Roact logic in the event that it does not yet meet the requirements for Concurrent Mode.</p>"},{"location":"api-reference/react-roblox/#reactrobloxcreateportal","title":"<code>ReactRoblox.createPortal</code>","text":"<p>Refer to <code>ReactDOM.createPortal</code> documentation.</p>"},{"location":"api-reference/react-roblox/#reactrobloxact","title":"<code>ReactRoblox.act</code>","text":"<p>Used for testing code with scheduling logic mocked. This ensures that tests behave consistently and don't batch work unpredictably across frames. <code>act</code> executes a function and then plays forward the mock scheduler after it's done, and should be used to wrap any interactions that trigger updates to a React UI.</p> <p>More info on using <code>act</code> can be found in the migration guide.</p> <p>Refer to ReactDOM's <code>act</code> testing documentation for more high-level guidance.</p>"},{"location":"api-reference/react-roblox/#deviations_1","title":"Deviations","text":"<p>In production, <code>ReactRoblox.act</code> will not be available. Set the global value <code>_G.__ROACT_17_INLINE_ACT__</code> to <code>true</code> in order to enable this behavior in tests.</p> <p>Info</p> <p>This behavior is still a work in progress, and there may be changes to how React Lua detects whether or not it should provide the <code>act</code> function. For now, use the global <code>__ROACT_17_INLINE_ACT__</code> to enable it for tests.</p>"},{"location":"api-reference/react-roblox/#reactrobloxevent","title":"<code>ReactRoblox.Event</code>","text":"<p>Roact-only</p> <p>Re-exports <code>React.Event</code>. This is only exposed for backwards compatibility; please prefer to use <code>React.Event</code>.</p>"},{"location":"api-reference/react-roblox/#reactrobloxchange","title":"<code>ReactRoblox.Change</code>","text":"<p>Roact-only</p> <p>Re-exports <code>React.Change</code>. This is only exposed for backwards compatibility; please prefer to use <code>React.Change</code>.</p>"},{"location":"api-reference/react/","title":"React","text":"<p>Info</p> <p>This page is intended to provide brief descriptions, examples, and notes about deviations in behavior or API. For complete feature documentation of upstream-aligned features, follow the <code>View React Docs</code> link and consult the React JS docs.</p> <p>The <code>React</code> package is the entry point for most React logic and behavior. Most of its API members align directly to their equivalents in React JS. Some API members have slightly different behavior, different guidance around their usage, or slightly different function signatures to better accommodate Luau functionality and idioms.</p>"},{"location":"api-reference/react/#api-deviations","title":"API Deviations","text":""},{"location":"api-reference/react/#not-supported","title":"Not Supported","text":"<p>The following API members are notable absences relative to React JS 17.0.1:</p> <ul> <li><code>React.createFactory</code> - Considered legacy and will likely not be included</li> <li><code>React.useDebugValue</code> - Not yet implemented</li> </ul> <p>Additionally, the following APIs are implemented, but have blocking issues that prevent them from being fully supported or usable:</p> <ul> <li><code>React.lazy</code></li> <li><code>React.Suspense</code></li> </ul>"},{"location":"api-reference/react/#undocumented","title":"Undocumented","text":"<p>The <code>React</code> packages includes some features that are undocumented in React JS 17.0.1, but are present in its implementation. The following API members may be less stable than the features that are fully documented upstream:</p> <ul> <li><code>React.createMutableSource</code></li> <li><code>React.useMutableSource</code></li> </ul>"},{"location":"api-reference/react/#unique-to-roblox","title":"Unique to Roblox","text":"<p><code>React</code> also exports a small collection of Lua-exclusive APIs which have no upstream equivalent. These are designed to facilitate better integration with the Luau language and the Roblox engine functionality.</p> <ul> <li><code>React.None</code></li> <li><code>React.Event</code></li> <li><code>React.Change</code></li> <li><code>React.Tag</code></li> <li><code>React.useBinding</code></li> <li><code>React.createBinding</code></li> <li><code>React.joinBindings</code></li> </ul>"},{"location":"api-reference/react/#reactcomponent","title":"<code>React.Component</code>","text":"<p>Luau does not have ES6's class semantics, so class components work slightly differently from React JS in the following ways:</p> <ul> <li>Use <code>Component:extend</code> in place of ES6 class semantics</li> <li>Implement an <code>init</code> method on components instead of a constructor</li> </ul> <p>React-lua also includes the following deviations:</p> <ul> <li>Instead of initializing component state by assigning a value to <code>self.state</code> in the <code>init</code> method, use <code>setState</code> as you would elsewhere (this is inherited from Legacy Roact for compatibility and consistency)</li> <li>Error boundaries are not fully supported in React-lua at this time due to a limitation in recursive <code>pcall</code> depth</li> </ul> <pre><code>local MyComponent = React.Component:extend(\"MyComponent\")\n\nfunction MyComponent:init()\n    self:setState({ expanded = true })\nend\n\nfunction MyComponent:render()\n    return React.createElement(\"TextButton\", {\n        Text = if expanded\n            then self.props.text\n            else \"Click to Expand\",\n        Size = if expanded\n            then UDim2.new(1, 0, 0, 200)\n            else UDim2.new(1, 0, 0, 30),\n        [React.Event.Activated] = function()\n            self:setState(function(expanded)\n                return { expanded = not expanded }\n            end)\n        end\n    })\nend\n</code></pre> <p>Check the deviations guide for more detailed information.</p>"},{"location":"api-reference/react/#reactpurecomponent","title":"<code>React.PureComponent</code>","text":"<p>The same deviations to <code>React.Component</code> apply equivalently to <code>React.PureComponent</code>. Check the deviations guide for more detailed information.</p>"},{"location":"api-reference/react/#reactmemo","title":"<code>React.memo</code>","text":"<pre><code>local MyComponent = React.memo(function MyComponent(props)\n    --[[ render using props ]]\nend)\n</code></pre> <p>Guidance specified in the React documentation applies for React Lua as well. Use this only as a performance optimization, and only when relevant to the use case.</p>"},{"location":"api-reference/react/#reactcreateelement","title":"<code>React.createElement</code>","text":"<p>While the <code>createElement</code> API is aligned to React JS, current tooling in Luau does not support an equivalent for JSX. When writing React Lua code, you'll use <code>createElement</code> directly much more often than in React JS.</p> <pre><code>--[[\nReact.createElement(\n    type,\n    [props],\n    [...children]\n)\n]]\nlocal element = React.createElement(\n    \"Frame\",\n    { Size = UDim2.fromScale(1, 1) },\n    React.createElement(\"TextLabel\", { Text = \"Child1\" })\n    React.createElement(\"TextLabel\", { Text = \"Child2\" })\n)\n</code></pre>"},{"location":"api-reference/react/#reactcloneelement","title":"<code>React.cloneElement</code>","text":"<p>Clone an existing element, using its provided config values (props, <code>ref</code>, and <code>key</code>) as a starting point.</p> <pre><code>local onlyChild = React.Children.only(props.children)\nlocal cloned = React.cloneElement(onlyChild, { Text = \"Cloned\" })\n</code></pre>"},{"location":"api-reference/react/#reactisvalidelement","title":"<code>React.isValidElement</code>","text":"<p>Returns <code>true</code> if the provided value is a React element; otherwise, returns <code>false</code>.</p> <pre><code>if React.isValidElement(props.frameContents) then\n    return React.createElement(\"Frame\", { Size = UDim2.fromScale(1, 1) }, props.frameContents)\nend\n</code></pre>"},{"location":"api-reference/react/#reactchildren","title":"<code>React.Children</code>","text":"<p>Warning</p> <p>This field can often be confused with a Legacy Roact API called <code>Roact.Children</code>. In the legacy API, <code>Roact.Children</code> was a special opaque prop key that could be used to pass children through props tables. In React Lua, the <code>children</code> string key is reserved and used instead. Learn more about how to migrate away from <code>Roact.Children</code> in the migration guide.</p> <p>A collection of utilities for manipulating the children provided to a React component via <code>props.children</code> or <code>self.props.children</code>. The <code>children</code> property should always be used as an opaque data structure; manipulate it via <code>React.Children</code> utilities rather than accessing it directly.</p> <p>There are a few notable deviations:</p> <ul> <li>React Children values with type \"userdata\" will be treated as nil in callbacks. This means that a <code>React.None</code> child passed to <code>React.Children.forEach</code> or <code>React.Children.map</code> will be treated the same as a nil value or boolean in the callbacks. <code>React.Children.count</code> will not include userdata children in the count.</li> <li>The <code>context</code> argument for mapChildren is not passed to the callback. This is typically used to pass <code>this</code> in javascript, but does not have an equivalent in Lua.</li> <li>React Children utilities work with tables with string keys as well as arrays</li> </ul>"},{"location":"api-reference/react/#reactchildrenmap","title":"<code>React.Children.map</code>","text":"<p>Use <code>React.Children.map</code> to transform each member child of the <code>children</code> property.</p> <pre><code>local ListItem = require(script.Parent.ListItem)\n\nlocal function OrderedList(props)\n    return React.createElement(\n        \"Frame\",\n        { Size = UDim2.fromScale(1, 1) },\n        React.Children.map(props.children, function(child, i)\n            return React.createElement(ListItem, { layoutOrder = i }, child)\n        end)\n    )\nend\n</code></pre>"},{"location":"api-reference/react/#reactchildrenforeach","title":"<code>React.Children.forEach</code>","text":"<p>Accepts a function that will be called with each member child of the <code>children</code> property. Similar to <code>React.Children.map</code>, but the provided callback does not return a new child.</p> <pre><code>local ListItem = require(script.Parent.ListItem)\nlocal Separator = require(script.Parent.Separator)\n\nlocal function SeparatorList(props)\n    local listItems = {}\n\n    React.Children.forEach(props.children, function(child, i)\n        table.insert(listItems, React.createElement(ListItem, { layoutOrder = i*2 }, child))\n        table.insert(listItems, React.createElement(Separator, { layoutOrder = i*2 + 1 }))\n    end)\n\n    return React.createElement(\n        \"Frame\",\n        { Size = UDim2.fromScale(1, 1) },\n        listItems\n    )\nend\n</code></pre>"},{"location":"api-reference/react/#reactchildrencount","title":"<code>React.Children.count</code>","text":"<p>Returns the number of child members in the provided <code>children</code> object.</p> <pre><code>local function List(props)\n    print(string.format(\"Render list with %d children\", React.Children.count(props.children)))\n\n    return React.createElement(\n        \"Frame\",\n        { Size = UDim2.fromScale(1, 1) },\n        props.children,\n    )\nend\n</code></pre>"},{"location":"api-reference/react/#reactchildrenonly","title":"<code>React.Children.only</code>","text":"<p>Asserts that the provided object is a single React element. If the provided object is an array or table of elements, this function will throw; otherwise, it returns the element that was passed into it.</p> <pre><code>local function Box(props)\n    local element = React.Children.only(props.children)\n\n    return React.createElement(\n        \"Frame\",\n        { Size = UDim2.fromOffset(100, 100) },\n        element,\n    )\nend\n</code></pre>"},{"location":"api-reference/react/#reactchildrentoarray","title":"<code>React.Children.toArray</code>","text":"<p>Converts the opaque <code>children</code> prop into an array. The resulting value can then be manipulated with typical Lua array semantics or using utility methods that operate on array-like Lua tables.</p> <pre><code>local Array = require(Packages.Collections).Array\n\nlocal function FilteredList(props)\n    local children = React.Children.toArray(props.children)\n\n    return React.createElement(\n        \"Frame\",\n        { Size = UDim2.fromScale(1, 1) },\n        Array.filter(children, props.filterFn),\n    )\nend\n</code></pre>"},{"location":"api-reference/react/#reactfragment","title":"<code>React.Fragment</code>","text":"<p>Renders multiple components using a special component called a <code>Fragment</code>. Fragments are useful for returning multiple elements from a single component without creating additional UI elements.</p> <pre><code>function MyComponent:render()\n    return React.createElement(\n        React.Fragment,\n        nil,\n        React.createElement(\"TextLabel\", { Text = \"Some text.\" }),\n        React.createElement(\"TextButton\", { Text = \"Button\" }),\n    )\nend\n</code></pre>"},{"location":"api-reference/react/#reactcreateref","title":"<code>React.createRef</code>","text":"<p>Creates a Ref object which can be used to access underlying Instances in the DataModel. Use this as an escape hatch when you need to interact directly with Roblox Instances (or equivalent in other environments).</p> <pre><code>local MyComponent = React.Component:extend(\"MyComponent\")\n\nfunction MyComponent:init()\n    self.inputRef = React.createRef()\nend\n\nfunction MyComponent:render()\n    return React.createElement(\"TextBox\", { ref = self.inputRef })\nend\n\nfunction MyComponent:componentDidMount()\n    self.inputRef.current:CaptureFocus()\nend\n</code></pre>"},{"location":"api-reference/react/#reactforwardref","title":"<code>React.forwardRef</code>","text":"<p>In some cases, you may want your component to accept a ref and forward it to a child, typically a Roblox host component.</p> <p><code>React.forwardRef</code> accepts a render function that receives <code>props</code> (just like a function component) as well as a <code>ref</code> object, and can then assign its ref within the render callback.</p> <pre><code>local FancyButton = React.forwardRef(function(props, ref)\n    return React.createElement(\"TextButton\", {\n        ref = ref,\n        Text = props.text,\n        [React.Event.Activated] = props.onActivated,\n    }, props.children)\nend)\n\n-- You can now get a ref directly to the TextButton Instance:\nlocal ref = React.createRef()\nReact.createElement(FancyButton, { ref = ref, text = \"Click me!\" })\n</code></pre>"},{"location":"api-reference/react/#reactcreatecontext","title":"<code>React.createContext</code>","text":"<p>Creates a Context object. Context is a mechanism for passing information through many levels of the React component tree without needing to explicitly pass it down at each level.</p> <pre><code>local MyContext = React.createContext(defaultValue)\n</code></pre>"},{"location":"api-reference/react/#contextprovider","title":"<code>Context.Provider</code>","text":"<p>The Context object returned from <code>createContext</code> includes a <code>Provider</code> component, which can be used to pass a context value into the component tree.</p> <pre><code>React.createElement(MyContext.Provider, { value = someValue })\n</code></pre>"},{"location":"api-reference/react/#contextconsumer","title":"<code>Context.Consumer</code>","text":"<p>The Context object returned from <code>createContext</code> includes a <code>Consumer</code> component, which can be used to retrieve a context value that was provided higher up in the tree.</p> <pre><code>React.createElement(MyContext.Consumer, nil, function(value)\n    -- render something based on the context value\nend)\n</code></pre>"},{"location":"api-reference/react/#reactlazy","title":"<code>React.lazy</code>","text":"<p>Warning</p> <p>Though <code>React.lazy</code>'s functionality is implemented, it may not be especially useful without complete support for <code>React.Suspense</code>.</p> <p>Warning</p> <p>The <code>lazy</code> utility is designed for an ecosystem where loading modules can be expensive. This is rarely a concern in the context of Luau projects. Since <code>lazy</code> relies upon a dynamic call to <code>require</code>, tooling like type checking may not work correctly. Use <code>React.lazy</code> with caution and intent, and only if it has a measurable performance impact.</p> <p>Wraps a component in a lazy-loading container that waits until the component is used in a render before calling the function to load it.</p> <pre><code>local Component = React.lazy(function()\n    return require(script.Parent.Component)\nend)\n</code></pre>"},{"location":"api-reference/react/#reactsuspense","title":"<code>React.Suspense</code>","text":"<p>Warning</p> <p>While <code>React.Suspense</code> is technically implemented, it should be considered unusable as of version <code>17.0.1</code>. This is due to a limitation in Luau around recursive <code>pcall</code> depth. Future updates to React will unravel the recursive traversal and enable these features. Future version of React eliminate this recursive structure and should enable full use of <code>Suspense</code> and error boundaries.</p> <p>Renders a subtree of children that can yield. If the children suspend while rendering, the <code>fallback</code> field provided will be used until the children have resolved their render.</p> <pre><code>React.createElement(\n    React.Suspense,\n    {\n        fallback = React.createElement(\"TextLabel\", {\n            Text = \"Loading...\",\n        })\n    },\n    React.createElement(SomeContents)\n)\n</code></pre>"},{"location":"api-reference/react/#hooks","title":"Hooks","text":"<p>Hooks allow simple function components to introduce stateful behaviors without incurring the overhead or complexity of the full Component lifecycle.</p>"},{"location":"api-reference/react/#reactusestate","title":"<code>React.useState</code>","text":"<p><code>useState</code> is a React Hook that creates a state variable that can be used and updated by your component. Updating the state will cause the component to re-render.</p> <pre><code>local function ClickCounter(props)\n    local count, setCount = React.useState(0)\n\n    return React.createElement(\"TextButton\", {\n        Text = string.format(\"Clicked %d times\", count)\n        -- Clicking the button updates the count, which re-renders the component\n        [React.Event.Activated] = function()\n            setCount(count + 1)\n        end\n    })\nend\n</code></pre> <p>Note that Luau does not have syntactic sugar for destructuring like javascript:</p> <pre><code>const [value, setValue] = useState(0);\n</code></pre> <p>However, it does support multiple return values, so React Lua supports a very similar usage:</p> <pre><code>local value, setValue = useState(0)\n</code></pre>"},{"location":"api-reference/react/#reactuseeffect","title":"<code>React.useEffect</code>","text":"<p><code>useEffect</code> is a React Hook that causes a side effect to run after a component's render has completed, allowing synchronization with external systems.</p> <pre><code>local UserInputService = game:GetService(\"UserInputService\")\nlocal LastInputTypeChanged = UserInputService.LastInputTypeChanged\n\nlocal function LastInputLabel(props)\n    local lastInput, setLastInput = React.useState(Enum.UserInputType.None)\n\n    React.useEffect(function()\n        -- Update `lastInput` state when the engine signal fires\n        local connection = LastInputTypeChanged:Connect(setLastInput)\n\n        return function()\n            connection:Disconnect()\n        end\n    end, {})\n\n    return React.createElement(\"TextLabel\", {\n        Text = string.format(\"Last input: %s\", lastInput)\n    })\nend\n</code></pre>"},{"location":"api-reference/react/#reactusecontext","title":"<code>React.useContext</code>","text":"<p><code>useContext</code> is a React Hook that allows a component to read from and subscribe to context values provided from <code>createContext</code>.</p> <pre><code>local ThemeContext = require(...)\n\nlocal function ThemedLabel(props)\n    local theme = React.useContext(ThemeContext)\n\n    return React.createElement(\"TextLabel\", {\n        TextSize = theme.TextSize,\n        TextColor3 = theme.TextColor3,\n        -- ...\n    })\nend\n</code></pre>"},{"location":"api-reference/react/#reactusereducer","title":"<code>React.useReducer</code>","text":"<p><code>useReducer</code> is a React Hook that introduces a reducer function to your component for managing complex state. See the <code>Rodux</code> documentation for detailed examples of the reducer pattern in Lua.</p> <pre><code>local function reducer(state, action)\n    if action.type == \"add\" then\n        return {\n            value = state.value + action.value,\n            ops = state.ops + 1,\n        }\n    elseif action.type == \"multiply\" then\n        return {\n            value = state.value * action.value,\n            ops = state.ops + 1,\n        }\n    end\nend\n\nlocal function Calculator(props)\n    local state, dispatch = React.useReducer(reducer, { value = 1, ops = 0 })\n\n    return React.createElement(React.Fragment, nil,\n        React.createElement(\"TextLabel\", {\n            Text = string.format(\"value: %d - ops: %d\", state.value, state.ops)\n        })\n        React.createElement(\"TextButton\", {\n            Text = \"Add 4\",\n            [React.Event.Activated] = function()\n                dispatch({ type = \"add\", value = 4 })\n            end\n        })\n        React.createElement(\"TextButton\", {\n            Text = \"Multiply by 3\",\n            [React.Event.Activated] = function()\n                dispatch({ type = \"multiply\", value = 3 })\n            end\n        })\n    )\nend\n</code></pre> <p>Just like the <code>useState</code> hook, we use Luau's multiple returns to approximate JavaScript's destructuring. The following JS:</p> <pre><code>const [state, dispatch] = useReducer(reducer, initialState);\n</code></pre> <p>Becomes:</p> <pre><code>local state, dispatch = useReducer(reducer, initialState)\n</code></pre>"},{"location":"api-reference/react/#reactusecallback","title":"<code>React.useCallback</code>","text":"<p><code>useCallback</code> is a React Hook that allows a component to cache a function definition between re-renders.</p> <pre><code>local ItemTile = require(...)\nlocal equipItem = require(...)\n\nlocal function EquippableItemTile(props)\n    local onClick = React.useCallback(function()\n        equipItem(props.itemId)\n    end, { props.itemId })\n\n    return React.createElement(ItemTile, {\n        text = props.itemName,\n        onTileClicked = onClick,\n    })\nend\n</code></pre>"},{"location":"api-reference/react/#reactusememo","title":"<code>React.useMemo</code>","text":"<p><code>useMemo</code> is a React Hook that caches a computed value between re-renders.</p> <pre><code>local function filterByCategory(todos, category)\n    -- ...\n    return filteredTodos\nend\n\nlocal function FilteredTodoList(props)\n    local filteredTodos = React.useMemo(function()\n        return filterByCategory(props.todos, props.selectedCategory)\n    end, { props.todos, props.selectedCategory })\n\n    return React.createElement(TodoList, {\n        items = filteredTodos,\n    })\nend\n</code></pre>"},{"location":"api-reference/react/#reactuseref","title":"<code>React.useRef</code>","text":"<p><code>useRef</code> is a React Hook that stores a value that's not needed for rendering. In other words, refs are arbitrary value containers that do no invoke re-renders when they change.</p> <p>Refs can be used for a variety of purposes, including assigning them to the <code>ref</code> field of an element to get a reference to the underlying Roblox <code>Instance</code>.</p> <pre><code>local function TextBoxWithButton(props)\n    local textBoxRef = React.useRef(nil)\n\n    return React.createElement(React.Fragment, nil,\n        React.createElement(\"TextBox\", { ref = textBoxRef }),\n        React.createElement(\"TextButton\", {\n            Text = \"-&gt;\",\n            [React.Event.Activated] = function()\n                textBoxRef.current:CaptureFocus()\n            end\n        }),\n    )\nend\n</code></pre>"},{"location":"api-reference/react/#reactuseimperativehandle","title":"<code>React.useImperativeHandle</code>","text":"<p><code>useImperativeHandle</code> is a React Hook that provides a way to customize a handle that's exposed as a ref.</p> <p>This allows a ref to be defined around a narrower or more convenient interface rather than a direct reference to the underlying <code>Instance</code>, and can be used to expose a customized ref interface from a function or class component.</p> <pre><code>local ControllableScrollingFrame = React.forwardRef(function(props, ref)\n    local innerRef = React.useRef(nil)\n\n    React.useImperativeHandle(ref, function()\n        return {\n            scrollToTop = function()\n                innerRef.current.CanvasPosition = Vector2.new(0, 0)\n            end\n        }\n    end, {})\n\n    return React.createElement(\"ScrollingFrame\", {\n        ref = innerRef\n        -- ...\n    })\nend)\n\n-- Another component will be able to access this interface via a ref:\nlocal function TodoListApp(props)\n    local scrollingFrameRef = React.useRef(nil)\n\n    return React.createElement(ControllableScrollingFrame,\n        {\n            ref = scrollingFrameRef\n        },\n        React.createElement(TodoList, {\n            items = props.todoItems,\n        }),\n        React.createElement(\"TextButton\", {\n            Text = \"Back to top\",\n            [React.Event.Activated] = function()\n                scrollingFrameRef.current.scrollToTop()\n            end\n        })\n    )\nend\n</code></pre>"},{"location":"api-reference/react/#reactuselayouteffect","title":"<code>React.useLayoutEffect</code>","text":"<p><code>useLayoutEffect</code> is an alternative version of <code>useEffect</code> that fires after the component runs its render function, but before the Roblox <code>Instance</code> hierarchy is reconciled with the new properties.</p> <p>Caution</p> <p>Use this hook sparingly. While <code>useEffect</code> runs asynchronously after a render operation is completed, <code>useLayoutEffect</code> runs during an update in between rendering and reconciliation: this can introduce performance issues if used carelessly.</p> <p>In React JS, <code>useLayoutEffect</code> is most often used to measure and position elements before the browser repaints them. It's not yet clear how this use case translates to Roblox usage, and this hook should be used with caution until performance is investigated in detail and best practices emerge.</p>"},{"location":"api-reference/react/#reactusebinding","title":"<code>React.useBinding</code>","text":"<p>A hook introduced in React Lua that creates a <code>Binding</code> object. Bindings are isolated containers that automatically update. Creates and returns a binding and its associated updater function as multiple return values, similar to <code>useState</code>.</p> <pre><code>local function DisplaysSize(props)\n    local absSize, setAbsSize = React.useBinding(Vector2.new(0, 0))\n    return React.createElement(React.Fragment, nil,\n        React.createElement(\"ImageLabel\", {\n            Image = props.image,\n            [React.Change.AbsoluteSize] = function(rbx)\n                setAbsSize(rbx.AbsoluteSize)\n            end,\n        }),\n        React.createElement(\"TextLabel\", {\n            Text = absSize:map(function(value)\n                return \"X = \" .. tostring(value.X) .. \"; Y = \" .. tostring(value.Y)\n            end)\n        }\n    )\nend\n</code></pre> <p>A <code>Binding</code> has the following API:</p>"},{"location":"api-reference/react/#getvalue","title":"<code>getValue</code>","text":"<p>Warning</p> <p>Using <code>getValue</code> inside a component's <code>render</code> method is likely to result in using stale values! Using the unwrapped value directly won't allow React to subscribe to a binding's updates. To guarantee that a bound value will update, use the binding itself for your prop value or use the <code>map</code> method to map the value to a new one.</p> <p>Returns the internal value of the binding. This is helpful when updating a binding relative to its current value.</p> <pre><code>local function UpdateOnClick()\n    local count, setCount = React.useBinding(0)\n\n    return React.createElement(\"TextButton\", {\n        Text = count,\n        [React.Event.Activated] = function()\n            setCount(count:getValue() + 1)\n        end,\n    })\nend\n</code></pre>"},{"location":"api-reference/react/#map","title":"<code>map</code>","text":"<p>Returns a new binding that maps the existing binding's value to something else. For example, <code>map</code> can be used to transform an animation progress value like <code>0.4</code> into a property that can be consumed by a Roblox Instance like <code>UDim2.new(0.4, 0, 1, 0)</code>.</p> <p>In function components, the <code>useBinding</code> hook provides equivalent functionality, and guarantees that it will return the same binding and updater objects on subsequent calls (just like <code>useRef</code> does).</p> <pre><code>local function UpdateOnClick()\n    local count, setCount = React.useBinding(0)\n\n    return React.createElement(\"TextButton\", {\n        Text = count:map(function(value)\n            return string.format(\"Clicked %d times\", value)\n        end),\n        [React.Event.Activated] = function()\n            setCount(count:getValue() + 1)\n        end,\n    })\nend\n</code></pre>"},{"location":"api-reference/react/#reactprofiler","title":"<code>React.Profiler</code>","text":"<p>Refer to React Profiler API documentation.</p>"},{"location":"api-reference/react/#reactstrictmode","title":"<code>React.StrictMode</code>","text":"<p>Refer to React StrictMode API documentation.</p>"},{"location":"api-reference/react/#reactcreatemutablesource","title":"<code>React.createMutableSource</code>","text":"<p>Refer to relevant React RFC.</p>"},{"location":"api-reference/react/#reactusemutablesource","title":"<code>React.useMutableSource</code>","text":"<p>Refer to relevant React RFC.</p>"},{"location":"api-reference/react/#roblox-and-luau","title":"Roblox and Luau","text":"<p>The <code>React</code> package shipped from React Lua includes certain APIs designed specifically to account for nuances of the Luau language and to more easily leverage Roblox engine features.</p> <p>These APIs are unique to React Lua and do not have equivalents in React JS.</p>"},{"location":"api-reference/react/#reactnone","title":"<code>React.None</code>","text":"<p>A placeholder value that can be used to remove fields from a table (by changing the value to nil) when merging tables. This allows state fields to be nil-able despite lua treating table fields with <code>nil</code> values as semantically equivalent to absent fields.</p> <p><code>React.None</code> can be used to remove values from React class component state via these uses:</p> <ul> <li>When returning a table from the updater function passed to a class component's <code>setState</code> method     <pre><code>self:setState(function(_prevState)\n    return { myStateValue = React.None }\nend)\n</code></pre></li> <li>When passing a table directly to a class component's <code>setState</code> method     <pre><code>self:setState({ myStateValue = React.None })\n</code></pre></li> <li>When returning a table from a component's <code>getDerivedStateFromProps</code> implementation     <pre><code>function MyComponent.getDerivedStateFromProps(props, state)\n    return {\n        value = if props.someCondition\n            then state.value\n            else React.None\n    }\nend\n</code></pre></li> </ul> <p>Caution</p> <p><code>React.None</code> should be used sparingly; component state fields can generally be expressed more clearly with enumerated values or reasonable defaults than with nil-able values.</p> <p>Additionally, <code>React.None</code> is not intended to be used as a prop value, and may be reverted to nil by internal React logic in some cases if it's provided as one.</p>"},{"location":"api-reference/react/#reactevent","title":"<code>React.Event</code>","text":"<p>A special key that can be used to interact with events on Roblox Instance objects. Index into <code>React.Event</code> with the name of an Event that's defined for the given host Instance class in order to get a special prop key that connects to that event:</p> <pre><code>React.createElement(\"ImageButton\", {\n    [React.Event.MouseButton1Click] = function(rbx, x, y)\n        print(rbx, \"clicked at position\", x, y)\n    end,\n})\n</code></pre> <p>The event connection will be automatically created when the host element is mounted and automatically disconnected when the element is unmounted.</p> <p>Info</p> <p>Event callbacks receive the Roblox Instance as the first parameter, followed by any parameters yielded by the event.</p>"},{"location":"api-reference/react/#reactchange","title":"<code>React.Change</code>","text":"<p>A special key that can be used to interact with the <code>GetPropertyChangedSignal</code> method on Roblox Instance objects. Index into <code>React.Change</code> with the name of the property to get a special prop key that connects to the change signal of an Instance with that property:</p> <pre><code>React.createElement(\"ScrollingFrame\", {\n    [React.Change.CanvasPosition] = function(rbx)\n        print(\"ScrollingFrame scrolled to\", rbx.CanvasPosition)\n    end,\n})\n</code></pre> <p>The change signal connection will be automatically created when the host element is mounted and automatically disconnected when the element is unmounted.</p>"},{"location":"api-reference/react/#reacttag","title":"<code>React.Tag</code>","text":"<pre><code>local button = React.createElement(\"TextButton\", {\n    [React.Tag] = \"confirm-button\"\n    Text = \"Confirm\",\n    -- ...\n})\n</code></pre> <p>A special key that can be used to apply <code>CollectionService</code> tags to a host component.</p> <p>Multiple tags can be provided as a single space-delimited string. For example:</p> <pre><code>[React.Tag] = \"some-tag some-other-tag\"\n</code></pre> <p>will apply \"some-tag\" and \"some-other-tag\" as <code>CollectionService</code> tags to the underlying Roblox Instance when the component is mounted.</p>"},{"location":"api-reference/react/#reactcreatebinding","title":"<code>React.createBinding</code>","text":"<p>Creates a binding object. This function can be used outside of React function components and works similarly to <code>useBinding</code>.</p> <p>Use <code>createBinding</code> when you'd like to use a binding within a class component:</p> <pre><code>local DisplaysSize = React.Component:extend(\"DisplaysSize\")\n\nfunction DisplaysSize:init()\n    self.absSize, self.setAbsSize = React.createBinding(Vector2.new(0, 0))\nend\n\nfunction DisplaysSize:render()\n    return React.createElement(React.Fragment, nil,\n        React.createElement(\"ImageLabel\", {\n            Image = self.props.image,\n            [React.Change.AbsoluteSize] = function(rbx)\n                self.setAbsSize(rbx.AbsoluteSize)\n            end,\n        }),\n        React.createElement(\"TextLabel\", {\n            Text = self.absSize:map(function(value)\n                return \"X = \" .. tostring(value.X) .. \"; Y = \" .. tostring(value.Y)\n            end)\n        }\n    )\nend\n</code></pre>"},{"location":"api-reference/react/#reactjoinbindings","title":"<code>React.joinBindings</code>","text":"<p>Combines a map or array of bindings into a single binding. The new binding's value will have the same keys as the input table of bindings. Each time any of the input bindings update, the resulting binding will update as well with a new value.</p> <p>This capability can be used to create a single binding value that responds to changes from several input bindings: <pre><code>local function Flex()\n    local aSize, setASize = React.useBinding(Vector2.new())\n    local bSize, setBSize = React.useBinding(Vector2.new())\n\n    return React.createElement(\n        \"Frame\",\n        {\n            Size = React.joinBindings({aSize, bSize}):map(function(sizes)\n                local sum = Vector2.new()\n\n                for _, size in sizes do\n                    sum += size\n                end\n\n                return UDim2.new(0, sum.X, 0, sum.Y)\n            end),\n        },\n        React.createElement(\"Frame\", {\n            Size = UDim2.new(1, 0, 0, 30),\n            [React.Change.AbsoluteSize] = function(instance)\n                setASize(instance.Size)\n            end,\n        }),\n        React.createElement(\"Frame\", {\n            Size = UDim2.new(1, 0, 0, 30),\n            Position = aSize:map(function(size)\n                return UDim2.new(0, 0, 0, size.Y)\n            end),\n            [React.Change.AbsoluteSize] = function(instance)\n                setBSize(instance.Size)\n            end,\n        })\n    )\nend\n</code></pre></p>"},{"location":"api-reference/roact-compat/","title":"RoactCompat","text":"<p>The <code>RoactCompat</code> package is designed to have the same interface as legacy Roact. This should allow easier adoption of React Lua in existing Roact code.</p> <p><code>RoactCompat</code> is fully compatible with all React Lua logic. In particular, you may wish to use <code>RoactCompat</code> in combination with the <code>React</code> and <code>ReactRoblox</code> packages that provide the new interface.</p> <p>Caution</p> <p><code>RoactCompat</code> is not compatible with legacy Roact in any way. It should be used only as a drop-in replacement for legacy Roact, for the purposes of upgrading existing projects written for legacy Roact.</p>"},{"location":"api-reference/roact-compat/#roactcompatcomponent","title":"<code>RoactCompat.Component</code>","text":"<p>Re-exports React.Component.</p>"},{"location":"api-reference/roact-compat/#roactcompatpurecomponent","title":"<code>RoactCompat.PureComponent</code>","text":"<p>Re-exports React.PureComponent.</p>"},{"location":"api-reference/roact-compat/#roactcompatcreateelement","title":"<code>RoactCompat.createElement</code>","text":"<p>Re-exports React.createElement.</p>"},{"location":"api-reference/roact-compat/#roactcompatcreatecontext","title":"<code>RoactCompat.createContext</code>","text":"<p>Re-exports React.createContext.</p>"},{"location":"api-reference/roact-compat/#roactcompatcreateref","title":"<code>RoactCompat.createRef</code>","text":"<p>Re-exports React.createRef.</p>"},{"location":"api-reference/roact-compat/#roactcompatforwardref","title":"<code>RoactCompat.forwardRef</code>","text":"<p>Re-exports React.forwardRef.</p>"},{"location":"api-reference/roact-compat/#roactcompatmount","title":"<code>RoactCompat.mount</code>","text":"<pre><code>RoactCompat.mount(\n    element: ReactElement,\n    container: Instance?,\n    name: string?\n): RoactTree\n</code></pre> <p>Compatibility method mimicking legacy <code>Roact.mount</code>.</p> <p>For all intents and purposes, this should function equivalently to legacy Roact's <code>mount</code> function. Under the hood, RoactCompat takes the following steps:</p> <ol> <li>Creates a root using <code>React.createRoot</code><ul> <li>When <code>_G.__ROACT_17_COMPAT_LEGACY_ROOT__</code> is enabled, this will use <code>React.createLegacyRoot</code> instead</li> </ul> </li> <li>Calls <code>root:render</code> with the provided element<ul> <li>React's roots take complete control of the provided container, deleting all existing children. Legacy Roact does not tamper with existing children of the provided container. To mimic the legacy behavior, we use a <code>Portal</code> to mount into the container instead of providing it directly to the root.</li> <li>When <code>_G.__ROACT_17_INLINE_ACT__</code> is enabled, the <code>render</code> call is automatically wrapped in <code>ReactRoblox.act</code> to ensure that mounting behavior resolves synchronously in tests.</li> </ul> </li> <li>Returns an opaque handle to the root that can be used with <code>RoactCompat.update</code> and <code>RoactCompat.unmount</code></li> </ol>"},{"location":"api-reference/roact-compat/#roactcompatupdate","title":"<code>RoactCompat.update</code>","text":"<pre><code>RoactCompat.update(tree: RoactTree, element: ReactElement): RoactTree\n</code></pre> <p>Compatibility method mimicking legacy <code>Roact.update</code>.</p> <p>The first argument should be the value returned from a prior call to <code>RoactCompat.mount</code> or <code>RoactCompat.update</code>. This function will not work if the argument passed in was created with legacy Roact.</p>"},{"location":"api-reference/roact-compat/#roactcompatunmount","title":"<code>RoactCompat.unmount</code>","text":"<pre><code>RoactCompat.unmount(tree: RoactTreeHandle)\n</code></pre> <p>Compatibility method mimicking legacy <code>Roact.unmount</code>.</p>"},{"location":"api-reference/roact-compat/#roactcompatcreatefragment","title":"<code>RoactCompat.createFragment</code>","text":"<pre><code>RoactCompat.createFragment(elements: { [string | number]: ReactElement }): ReactElement\n</code></pre> <p>Compatibility method mimicking <code>Roact.createFragment</code>. Uses the special component <code>React.Fragment</code> under the hood.</p>"},{"location":"api-reference/roact-compat/#roactcompatonechild","title":"<code>RoactCompat.oneChild</code>","text":"<pre><code>RoactCompat.oneChild(\n    children: { [string | number]: ReactElement } | ReactElement | nil\n): ReactElement\n</code></pre> <p>Compatibility method mimicking <code>Roact.oneChild</code>. This function is similar to <code>React.Children.only</code>, but provides additional functionality to unwrap a table that may contain a single element.</p>"},{"location":"api-reference/roact-compat/#roactcompatsetglobalconfig","title":"<code>RoactCompat.setGlobalConfig</code>","text":"<pre><code>RoactCompat.setGlobalConfig(configValues: { [string]: boolean })\n</code></pre> <p>Compatibility method mimicking <code>Roact.setGlobalConfig</code>. This does not apply to React Lua, so calling this function is a no-op.</p> <p>Info</p> <p>If you need to apply global configuration to React Lua, you can do so by setting global values (see Configuration docs)</p>"},{"location":"api-reference/roact-compat/#roactcompatportal","title":"<code>RoactCompat.Portal</code>","text":"<p>Compatibility component mimicking <code>Roact.Portal</code>. Uses the React.createPortal function under the hood.</p>"},{"location":"api-reference/roact-compat/#roactcompatref","title":"<code>RoactCompat.Ref</code>","text":"<p>Compatibility field that mimics the special symbol key <code>Roact.Ref</code>. In RoactCompat, the <code>Ref</code> field is simply equal to the string \"ref\", which is a reserved prop key in React Lua.</p> <p>This allows prop tables that are written for legacy Roact:</p> <pre><code>Roact.createElement(\"TextLabel\", {\n    Text = \"Hello\",\n    [Roact.Ref] = textLabelRef,\n})\n</code></pre> <p>...to be equivalent to prop tables written for React Lua, which uses \"ref\" as a reserved prop name:</p> <pre><code>Roact.createElement(\"TextLabel\", {\n    Text = \"Hello\",\n    ref = textLabelRef,\n})\n</code></pre>"},{"location":"api-reference/roact-compat/#roactcompatchildren","title":"<code>RoactCompat.Children</code>","text":"<p>Compatibility field that mimics the special symbol key <code>Roact.Children</code>. In RoactCompat, the <code>Children</code> field is simply equal to the string \"children\", which is a reserved prop key in React Lua.</p> <p>This allows prop tables that are written for legacy Roact:</p> <pre><code>-- forwards the children provided to this component\nRoact.createElement(\"Frame\", nil, self.props[Roact.Children])\n</code></pre> <p>...to be equivalent to prop tables written for React Lua, which uses \"children\" as a reserved prop name:</p> <pre><code>-- forwards the children provided to this component\nRoact.createElement(\"Frame\", nil, self.props.children)\n</code></pre> <p>Caution</p> <p>This is not to be confused with <code>React.Children</code>, which is a set of utilities for transforming or interacting with sets of children passed to <code>createElement</code>.</p>"},{"location":"api-reference/roact-compat/#roactcompatnone","title":"<code>RoactCompat.None</code>","text":"<p>Re-exports React.None.</p>"},{"location":"api-reference/roact-compat/#roactcompatevent","title":"<code>RoactCompat.Event</code>","text":"<p>Re-exports React.Event.</p>"},{"location":"api-reference/roact-compat/#roactcompatchange","title":"<code>RoactCompat.Change</code>","text":"<p>Re-exports React.Change.</p>"},{"location":"api-reference/roact-compat/#roactcompatcreatebinding","title":"<code>RoactCompat.createBinding</code>","text":"<p>Re-exports ReactRoblox.createBinding.</p>"},{"location":"api-reference/roact-compat/#roactcompatjoinbindings","title":"<code>RoactCompat.joinBindings</code>","text":"<p>Re-exports ReactRoblox.joinBindings.</p>"},{"location":"api-reference/roact-compat/#roactcompatact","title":"<code>RoactCompat.act</code>","text":"<p>Re-exports ReactRoblox.act.</p>"},{"location":"migrating-from-legacy/adopt-new-features/","title":"Adopt New Features","text":"<p>React Lua ships with a number of features new to Roact that have been ported from React JS, in addition to a couple of new capabilities unique to the React in Lua ecosystem.</p>"},{"location":"migrating-from-legacy/adopt-new-features/#asynchronous-rendering","title":"Asynchronous Rendering","text":"<p>React Lua introduces a paradigm shift to the underlying rendering behavior that allows it to divide work across multiple frames and preserve high framerate and interactivity.</p> <p>This behavior is called Concurrent Mode rendering.</p> <p>React Lua will use Concurrent Mode by default in its <code>mount</code> compatibility layer.</p> <p>Info</p> <p>React Lua is aligned to React JS 17.0.1, which means that it has not inherited any changes to Concurrent Mode described in the React 18 documentation. As we begin to build React Lua 18, we may shift our distinctions similarly. For now, opting into Concurrent Mode is the best way to get the latest optimizations and ensure that your components are robust.</p>"},{"location":"migrating-from-legacy/adopt-new-features/#reactrobloxcreateroot","title":"<code>ReactRoblox.createRoot</code>","text":"<p>In legacy Roact, the <code>Roact.mount</code> function is used to render a component tree. In React JS 17 and older, the primary entry-point for rendering a component tree is <code>ReactDOM.render</code>, while the experimental <code>ReactDOM.createRoot</code> API is used to adopt Concurrent Mode.</p> <p>React Lua skips introducing the top-level <code>render</code> function from earlier versions of React JS, and instead provides the following for mounting Roact UI elements:</p> <ul> <li>The <code>createRoot</code>, <code>createBlockingRoot</code>, and <code>createLegacyRoot</code> APIs from React JS 17</li> <li>A compatibility layer that exports a <code>mount</code> function aligned with legacy Roact's API</li> </ul> <p>In new code, you should always use <code>ReactRoblox.createRoot</code>. The vast majority of existing Roact code should be compatible with <code>createRoot</code>, which enables Concurrent Mode and can greatly improve responsiveness for complex applications.</p> <p>If you run into problems with Concurrent Mode that are difficult to address, you may be interested in considering <code>ReactRoblox.createBlockingRoot</code> or <code>ReactRoblox.createLegacyRoot</code> at a cost to overall app responsiveness.</p>"},{"location":"migrating-from-legacy/adopt-new-features/#reactrobloxact","title":"<code>ReactRoblox.act</code>","text":"<p>When Concurrent Mode is enabled, React will attempt to schedule work evenly across rendering frames to keep the application running smoothly, even when UI rendering work has been queued up.</p> <p>However, this means that tests relying on synchronous rendering behavior will no longer function correctly. To fix this, use the <code>ReactRoblox.act</code> function to play scheduler logic forward (also re-exported as <code>RoactCompat.act</code>).</p>"},{"location":"migrating-from-legacy/adopt-new-features/#how-to-use-act","title":"How to Use <code>act</code>","text":"<p>The <code>ReactRoblox.act</code> utility works by:</p> <ol> <li>Running the provided function</li> <li>Performing queued work by playing forward React's internal scheduler</li> <li>Repeating step 2 until the queue is empty</li> </ol> <p>When running tests using the mock scheduler, the following scenarios will need to be wrapped in an <code>act</code> call:</p> <ul> <li>Rendering an initial tree with the <code>render</code> method of a React root or the <code>RoactCompat.mount</code> compatibility function (if the <code>__ROACT_17_INLINE_ACT__</code> global is set to true, this will happen automatically for <code>mount</code>, <code>update</code>, and <code>unmount</code>)</li> <li>Rendering updates with the <code>render</code> method of a React root</li> <li>Unmounting a tree by passing <code>nil</code> to the <code>render</code> method of a React root</li> <li>Calling <code>task.wait</code> or other yielding functions to allow engine callbacks to fire</li> <li>Triggering behavior that causes a component to update its state, including firing signals that your component has subscribed to</li> </ul> <p>Info</p> <p>In order to enable the <code>act</code> function, you'll need React to use the mocked version of its internal scheduler. To do this, set the <code>__ROACT_17_MOCK_SCHEDULER__</code> global to true in your testing configuration.</p>"},{"location":"migrating-from-legacy/adopt-new-features/#example","title":"Example","text":"<p>Many integration tests involve validating various states of a component and interacting with the component via virtual input events or mocked signals. The following is a comprehensive example of several of the above scenarios in practice.</p> <p>Suppose we have a component called <code>TooltipButton</code>:</p> <pre><code>local function TooltipButton(props)\n    local showTooltip, setShowTooltip = React.useState(false)\n\n    return React.createElement(\"Frame\", {\n        key = \"TooltipButton\",\n        Size = UDim2.fromScale(1, 1),\n    }, {\n        Button = React.createElement(\"TextButton\", {\n            Text = \"Show tooltip\",\n            Active = props.enabled,\n            [React.Event.Activated] = function()\n                setShowTooltip(true)\n                task.delay(props.tooltipFadeDelay, function()\n                    setShowTooltip(false)\n                end)\n            end,\n        })\n        Tooltip = if showTooltip\n            then React.createElement(\"TextLabel\", {\n                Text = \"Tooltip text!\",\n            })\n            else nil\n    })\nend\n</code></pre> <p>We'd like to write a test to validate the tooltip behavior. Here's how we might use <code>act</code> to guarantee that all scheduled work is flushed and our test works as expected:</p> <p>Info</p> <p>This example uses an internal Roblox library called Rhodium. It is used for mocking input events, and cannot be used by external developers. We've kept the example in the react-lua fork because it's still a useful example.</p> <pre><code>local React = require(Packages.React)\nlocal ReactRoblox = require(Packages.ReactRoblox)\n\nlocal container, root\nbeforeEach(function()\n    container = Instance.new(\"ScreenGui\")\n    container.Parent = Players.LocalPlayer.PlayerGui\n\n    root = ReactRoblox.createRoot(container)\nend)\n\nafterEach(function()\n    container:Destroy()\nend)\n\nit(\"shows a tooltip on click and hides it after a delay\", function()\n    -- Use `act` for the initial render\n    ReactRoblox.act(function()\n        -- Render the button in a disabled state\n        root:render(React.createElement(TooltipButton, {\n            enabled = false,\n            tooltipFadeDelay = 1,\n        }))\n    end)\n\n    expect(container.TooltipButton.Tooltip).toBeNil()\n    expect(container.TooltipButton.Button.Active).toBe(false)\n\n    -- Use `act` to re-render the tree\n    ReactRoblox.act(function()\n        -- Rerender in the enabled state\n        root:render(React.createElement(TooltipButton, {\n            enabled = true,\n            tooltipFadeDelay = 1,\n        }))\n    end)\n\n    expect(container.TooltipButton.Tooltip).toBeNil()\n    expect(container.TooltipButton.Button.Active).toBe(true)\n\n    -- Use `act` to trigger virtual input\n    local element = Rhodium.Element.new(container.TooltipButton.Button)\n    ReactRoblox.act(function()\n        -- Click the button to trigger the tooltip\n        element:click()\n        Rhodium.VirtualInput.waitForInputEventsProcessed()\n    end)\n\n    expect(container.TooltipButton.Tooltip).never.toBeNil()\n    expect(container.TooltipButton.Tooltip.Text).toEqual(\"Tooltip text!\")\n\n    -- Use `act` to resume queued renders after a delayed callback fires\n    ReactRoblox.act(function()\n        task.wait(1)\n    end)\n\n    expect(container.TooltipButton.Tooltip).toBeNil()\nend)\n</code></pre> <p>For more details and examples, refer to documentation on the <code>act</code> function in React JS.</p> <p>Info</p> <p>In new test code, consider adopting libraries like <code>dom-testing-library-lua</code> and <code>react-testing-library-lua</code>, which are ports of JS testing libraries that handle much of the <code>act</code> logic for you.</p>"},{"location":"migrating-from-legacy/adopt-new-features/#hooks","title":"Hooks","text":"<p>While async rendering is a paradigm shift for under-the-hood rendering behavior, hooks are a paradigm shift for component development. They're designed to be a more performant, composable, testable, and ergonomic approach to defining stateful behavior and side effects (relative to to class component lifecycle methods).</p> <p>You can access hooks via the <code>React</code> Package. In order to encourage migration to the new package conventions, <code>RoactCompat</code> does not export the hooks API. Follow the previous section to set up your dependencies appropriately.</p> <p>An excellent and comprehensive guide for hooks can be found in the React JS documentation; the example below will help illustrate what they look like when used in Luau.</p>"},{"location":"migrating-from-legacy/adopt-new-features/#hooks-example","title":"Hooks Example","text":"<p>The following is a simple example that uses two of the most common hooks: <code>useState</code> and <code>useEffect</code>.</p> <pre><code>local React = require(Packages.React)\n\nfunction ClickerComponent(props)\n    local count, setCount = React.useState(0)\n    local function onClick()\n        setCount(function(oldCount)\n             return oldCount + 1\n        end)\n    end\n\n    React.useEffect(function()\n        print(string.format(\"You've clicked %d times!\", count))\n    end)\n\n    return React.createElement(\"TextButton\", {\n        Text = tostring(count),\n        [React.Event.Activated] = onClick,\n    })\nend\n</code></pre> <p>Check the API Reference to see the complete list of hooks supported by React Lua.</p>"},{"location":"migrating-from-legacy/adopt-new-features/#utilities","title":"Utilities","text":""},{"location":"migrating-from-legacy/adopt-new-features/#reactmemo","title":"React.memo","text":"<p>The <code>memo</code> function can be used to memoize a function component, returning the same element if the same props are provided. This may be a helpful optimization in scenarios where a function component frequently re-renders without changes due to its parent re-rendering.</p> <p>Refer to the React JS documentation for more details and examples.</p>"},{"location":"migrating-from-legacy/adopt-new-features/#reactchildren","title":"React.Children","text":"<p>Under construction \ud83d\udd28</p>"},{"location":"migrating-from-legacy/adopt-new-features/#lua-only-features","title":"Lua-Only Features","text":"<p>In addition to the new features provided by aligning with React JS 17, a few new features have been added to extend and improve support for legacy Roact features.</p>"},{"location":"migrating-from-legacy/adopt-new-features/#usebinding-hook","title":"<code>useBinding</code> Hook","text":"<p>Legacy Roact introduces a concept called \"bindings\", a shorthand for the concept of \"unidirectional data bindings.\" You can learn more about bindings in the legacy Roact documentation.</p> <p>The legacy version of bindings were created similarly to refs, using a <code>createBinding</code> method that would be called in the <code>init</code> method of a class component. So how do we use bindings with function components?</p> <p>React Lua introduces, alongside the core hooks from React JS 17, an additional <code>useBinding</code> hook to address this case. You can use it much like a <code>useState</code> hook, except it will follow binding semantics: instead of triggering component re-renders, binding updates will directly update subscribed values.</p> <pre><code>local React = require(Packages.React)\n\nfunction ClickerComponent(props)\n    local count, setCount = React.useBinding(0)\n    local function onClick()\n        -- This will only update subscribed host properties, specifically the\n        -- Text field of the button that's rendered below\n        setCount(count:getValue() + 1)\n    end\n\n    React.useEffect(function()\n        print(string.format(\"You've clicked %d times!\", count))\n    end)\n\n    return React.createElement(\"TextButton\", {\n        Text = count:map(tostring),\n        [React.Event.Activated] = onClick,\n    })\nend\n</code></pre>"},{"location":"migrating-from-legacy/adopt-new-features/#reacttag","title":"<code>React.Tag</code>","text":"<p>Under Construction \ud83d\udd28</p>"},{"location":"migrating-from-legacy/convert-legacy-conventions/","title":"Updating Conventions and APIs","text":"<p>Almost all legacy Roact code can be patched to React Lua using the <code>RoactCompat</code> library. However, while <code>RoactCompat</code> is backwards compatible with with Legacy Roact, it does not export new React Lua features like hooks.</p> <p>When writing code exclusively for React Lua, you should access the primary APIs of React Lua through the <code>React</code> and <code>ReactRoblox</code> APIs, instead of through <code>RoactCompat</code>.</p> <ul> <li><code>React</code> exposes:<ul> <li>some core legacy Roact APIs unchanged (<code>createElement</code>, <code>createContext</code>, <code>Component</code>, <code>Change</code>/<code>Event</code>, etc.)</li> <li>some React-JS-aligned updates to other legacy Roact APIs (<code>createFragment</code> -&gt; <code>Fragment</code>, <code>oneChild</code> -&gt; <code>Children.only</code>, etc.)</li> <li>and several brand new APIs (<code>useState</code>, <code>useRef</code>, <code>memo</code>, <code>cloneElement</code>, etc.)</li> </ul> </li> <li><code>ReactRoblox</code> exposes:<ul> <li>the <code>createRoot</code> API, which replaces the <code>mount</code>/<code>update</code>/<code>unmount</code> APIs</li> <li>the <code>createPortal</code> API, which replaces the <code>Roact.Portal</code> component</li> </ul> </li> </ul> <p>To reduce confusion, try to avoid using <code>RoactCompat</code> and <code>React</code>/<code>ReactRoblox</code> in the same file. If you are adding new React features to code that uses <code>RoactCompat</code> syntax, take the following steps to align conventions:</p> <ol> <li>Replace the <code>Roact</code> import with the <code>React</code> import</li> <li>Swap all uses of <code>Roact</code> with <code>React</code></li> <li>If the module uses any <code>Roact.Portal</code> instances, import the <code>ReactRoblox</code> package and replace them with <code>ReactRoblox.createPortal</code></li> <li>If the module uses <code>mount</code>/<code>update</code>/<code>unmount</code>, import the <code>ReactRoblox</code> package to replace them<ul> <li>Replace <code>Roact.mount</code> with <code>ReactRoblox.createRoot</code> followed by <code>root:render</code></li> <li>Replace <code>Roact.update</code> with subsequent calls to <code>root:render</code></li> <li>Replace <code>Roact.unmount</code> by calling <code>root:unmount</code></li> </ul> </li> <li>Begin adopting new features exported from the <code>React</code> package as needed</li> </ol>"},{"location":"migrating-from-legacy/convert-legacy-conventions/#api-conversions","title":"API Conversions","text":"<p>React Lua adopts the naming conventions and API shape of React JS wherever possible, with small deviations made to accommodate the distinct features of the Luau language. Using new naming conventions and APIs helps to align with the React JS ecosystem and reduce friction and mental overhead when troubleshooting or browsing documentation.</p> <p>Even though React Lua is designed to be largely compatible with legacy Roact, updating these conventions when adopting new features is highly encouraged.</p>"},{"location":"migrating-from-legacy/convert-legacy-conventions/#mounting-updating-and-unmounting","title":"Mounting, Updating, and Unmounting","text":"<p>Legacy Roact uses three functions to manage the lifecycle of an entire Roact tree composed of numerous components. This is typically the entry point into Roact-managed UI.</p> <p>In React Lua, the equivalent mechanisms use a new concept called a \"root\" to more clearly encapsulate this behavior.</p> <ul> <li><code>ReactRoblox.createRoot</code></li> <li><code>ReactRoblox.createBlockingRoot</code></li> <li><code>ReactRoblox.createLegacyRoot</code></li> </ul> <p>Since the root needs to access a Roblox <code>Instance</code> in order to attach to it, these functions are exported through the <code>ReactRoblox</code> package, also known as a \"renderer\". A renderer takes the abstract descriptions of UI generated by React components and turns them into a concrete UI element tree. You can think of the <code>ReactRoblox</code> package as the semantic equivalent of the <code>react-dom</code> package in the React JS ecosystem.</p>"},{"location":"migrating-from-legacy/convert-legacy-conventions/#legacy-roact","title":"Legacy Roact","text":"<pre><code>local PlayerGui = game:GetService(\"Players\").LocalPlayer.PlayerGui\nlocal Roact = require(Packages.Roact)\n\nlocal roactTree = Roact.mount(Roact.createElement(\"TextLabel\", {\n    Text = \"Hello world!\",\n}, PlayerGui)\n\ntask.wait(3)\n\nroactTree = Roact.update(roactTree, Roact.createElement(\"TextLabel\", {\n    Text = \"Hello Roblox!\",\n})\n\ntask.wait(3)\n\nRoact.unmount(roactTree)\n</code></pre>"},{"location":"migrating-from-legacy/convert-legacy-conventions/#react-lua","title":"React Lua","text":"<pre><code>local PlayerGui = game:GetService(\"Players\").LocalPlayer.PlayerGui\nlocal React = require(Packages.React)\nlocal ReactRoblox = require(Packages.ReactRoblox)\n\n-- React Lua roots will take full ownership of the instance provided to them,\n-- so we should not create a root using PlayerGui directly\nlocal container = Instance.new(\"Folder\")\ncontainer.Parent = PlayerGui\n\nlocal root = ReactRoblox.createRoot(container)\nroot:render(Roact.createElement(\"TextLabel\", {\n    Text = \"Hello world!\",\n})\n\ntask.wait(3)\n\nroot:render(Roact.createElement(\"TextLabel\", {\n    Text = \"Hello Roblox!\",\n})\n\ntask.wait(3)\n\nroot:render(nil)\n</code></pre> <p>Warning</p> <p>The <code>createBlockingRoot</code> and <code>createLegacyRoot</code> functions will opt out of concurrent rendering, a feature of React Lua that allows smooth, scalable UI by dividing units of work across multiple frames when large amounts of UI changes are needed. We always recommend using <code>createRoot</code> unless you know what you're doing.</p>"},{"location":"migrating-from-legacy/convert-legacy-conventions/#component-lifecycle-names","title":"Component Lifecycle Names","text":"<p>Legacy Roact used simplified names for component lifecycle functions to alleviate redundancy when defining lifecycle methods with syntax like <code>function MyComponent:didMount() ... end</code>.</p> <p>However, React Lua prefers to align as close as possible to React JS to reduce friction when referring to resources from the React JS ecosystem (questions, tutorials, examples, documentation, etc.). It's recommended to update class component lifecycle names to match React JS.</p> <ul> <li><code>didMount</code> \u27a1 <code>componentDidMount</code></li> <li><code>shouldUpdate</code> \u27a1 <code>shouldComponentUpdate</code></li> <li><code>didUpdate</code> \u27a1 <code>componentDidUpdate</code></li> <li><code>didMount</code> \u27a1 <code>componentDidMount</code></li> <li><code>willUpdate</code> \u27a1 <code>UNSTABLE_componentWillUpdate</code><ul> <li>It's recommended to use the <code>UNSTABLE_</code> prefix here, since the <code>componentWillUpdate</code> method is deprecated</li> </ul> </li> <li><code>willUnmount</code> \u27a1 <code>componentWillUnmount</code></li> </ul>"},{"location":"migrating-from-legacy/convert-legacy-conventions/#reserved-keys","title":"Reserved Keys","text":"<p>Legacy Roact went out of its way to let all prop keys be valid for component developers to use. In React Lua, a small subset of prop keys are reserved for internal use to make them simple to provide.</p> <ul> <li><code>[Roact.Ref]</code> becomes <code>ref</code></li> <li><code>[Roact.Children]</code> becomes <code>children</code></li> </ul> <p>You can index <code>props.children</code> to refer to the children provided to a component, and use <code>ref</code> as a key to an element to provide a ref to it.</p>"},{"location":"migrating-from-legacy/convert-legacy-conventions/#legacy-roact_1","title":"Legacy Roact","text":"<pre><code>local FocusButton = Roact.Component:extend(\"FocusButton\")\n\nfunction FocusButton:init()\n    self.ref = Roact.createRef()\nend\n\nfunction FocusButton:render()\n    return Roact.createElement(\"Button\", {\n        Size = self.props.Size,\n        [Roact.Ref] = self.ref\n    }, self.props[Roact.Children])\nend\n\nfunction FocusButton:didMount()\n    GuiService.SelectedObject = self.ref.current\nend\n</code></pre>"},{"location":"migrating-from-legacy/convert-legacy-conventions/#react-lua_1","title":"React Lua","text":"<pre><code>local FocusButton = Roact.Component:extend(\"FocusButton\")\n\nfunction FocusButton:init()\n    self.ref = Roact.createRef()\nend\n\nfunction FocusButton:render()\n    return Roact.createElement(\"Button\", {\n        Size = self.props.Size,\n        ref = self.ref\n    }, self.props.children)\nend\n\nfunction FocusButton:didMount()\n    GuiService.SelectedObject = self.ref.current\nend\n</code></pre>"},{"location":"migrating-from-legacy/convert-legacy-conventions/#contextconsumer","title":"Context.Consumer","text":"<p>Legacy Roact treats the special <code>Context.Consumer</code> component generated by <code>createContext</code> more like a typical component with a single prop (<code>render</code>) as its prop interface. React JS, on the other hand, uses a slightly abbreviated structure.</p> <p>The <code>Context.Consumer</code> component expects no props and a single child, where the child is the same mapping function that would be provided as the <code>render</code> prop in legacy Roact.</p>"},{"location":"migrating-from-legacy/convert-legacy-conventions/#legacy-roact_2","title":"Legacy Roact","text":"<pre><code>local ThemeContext = Roact.createContext(nil)\n\n-- ...\n\nlocal function Button(props)\n    return Roact.createElement(ThemeContext.Consumer, {\n        render = function(theme)\n            return Roact.createElement(\"TextButton\", {\n                BackgroundColor3 = theme.ButtonColor,\n                Text = props.text,\n                [Roact.Event.Activated] = props.onActivated,\n            })\n        end\n    })\nend\n</code></pre>"},{"location":"migrating-from-legacy/convert-legacy-conventions/#react-lua_2","title":"React Lua","text":"<pre><code>local ThemeContext = Roact.createContext(nil)\n\n-- ...\n\nlocal function Button(props)\n    return Roact.createElement(ThemeContext.Consumer, nil,\n        function(theme)\n            return Roact.createElement(\"TextButton\", {\n                BackgroundColor3 = theme.ButtonColor,\n                Text = props.text,\n                [Roact.Event.Activated] = props.onActivated,\n            })\n        end\n    )\nend\n</code></pre> <p>Info</p> <p>React Lua has a compatibility layer that will allow either structure to work as expected. If you'd like to see warnings that will help you migrate, enable the <code>__COMPAT_WARNINGS__</code> global.</p>"},{"location":"migrating-from-legacy/convert-legacy-conventions/#reactfragment","title":"React.Fragment","text":"<p>Legacy Roact treats fragments as a special kind of rendered object, distinct from a Roact element, using the <code>Roact.createFragment</code> function.</p> <p>In React Lua, however, fragments are nothing more than a special component type. Your component should return a single element with the <code>React.Fragment</code> component type, with the children provided as the element's children.</p>"},{"location":"migrating-from-legacy/convert-legacy-conventions/#legacy-roact_3","title":"Legacy Roact","text":"<pre><code>local function LabeledButton(props)\n    return Roact.createFragment({\n        Button = Roact.createElement(\"ImageButton\", {\n            Image = props.buttonIcon,\n        }),\n        Label = Roact.createElement(\"TextLabel\", {\n            Text = props.labelText,\n        }),\n    })\nend\n</code></pre>"},{"location":"migrating-from-legacy/convert-legacy-conventions/#react-lua_3","title":"React Lua","text":"<pre><code>local function LabeledButton(props)\n    return React.createElement(React.Fragment, nil, {\n        Button = React.createElement(\"ImageButton\", {\n            Image = props.buttonIcon,\n        }),\n        Label = React.createElement(\"TextLabel\", {\n            Text = props.labelText,\n        }),\n    })\nend\n</code></pre>"},{"location":"migrating-from-legacy/convert-legacy-conventions/#reactrobloxcreateportal","title":"ReactRoblox.createPortal","text":"<p>Legacy Roact uses a special <code>Roact.Portal</code> component to represent a portal. In React Lua, we align with upstream and export the <code>ReactRoblox.createPortal</code> function.</p> <p>Portals are considered to be a feature with renderer-specific functionality since they attach directly to a host instance. Any APIs that interact directly with Roblox Instances will be exported via <code>ReactRoblox</code> in order to maintain the renderer abstraction.</p>"},{"location":"migrating-from-legacy/convert-legacy-conventions/#legacy-roact_4","title":"Legacy Roact","text":"<pre><code>local PlayerGui = game:GetService(\"Players\").LocalPlayer.PlayerGui\n\nlocal function Modal(props)\n    return Roact.createElement(Roact.Portal, {\n        target = PlayerGui,\n    }, {\n        Modal = Roact.createElement(\"ScreenGui\", {}, {\n            Label = Roact.createElement(\"TextButton\", {\n                Text = \"Click me to close!\",\n                [Roact.Event.Activated] = props.onClose,\n            })\n        })\n    })\nend\n</code></pre>"},{"location":"migrating-from-legacy/convert-legacy-conventions/#react-lua_4","title":"React Lua","text":"<pre><code>local PlayerGui = game:GetService(\"Players\").LocalPlayer.PlayerGui\n\nlocal function Modal(props)\n    return ReactRoblox.createPortal({\n        Modal = Roact.createElement(\"ScreenGui\", {}, {\n            Label = Roact.createElement(\"TextButton\", {\n                Text = \"Click me to close!\",\n                [Roact.Event.Activated] = props.onClose,\n            })\n        })\n    }, PlayerGui)\nend\n</code></pre>"},{"location":"migrating-from-legacy/convert-legacy-conventions/#roactonechild","title":"Roact.oneChild","text":"<p>Legacy Roact provides an infrequently-used utility function called <code>oneChild</code> that guarantees that the argument provided to it is a table with only one child Roact element. If the provided table contains zero elements or two or more elements, <code>oneChild</code> will throw an error.</p> <p>React Lua inherits a somewhat similar function from React JS: <code>React.Children.only</code>. This function will throw an error if the provided argument is not itself a single child element. In other words, it expects a single child instead of a table containing only one child. This can be converted by unwrapping the provided children manually before passing them along to <code>React.Children.only</code>.</p> <p>Limiting a component to a single child isn't always necessary. Consider whether your component is capable of supporting an arbitrary number of children after all. In that case, you can simply remove the call to <code>Roact.oneChild</code>.</p>"},{"location":"migrating-from-legacy/convert-legacy-conventions/#eliminating-roactcompat","title":"Eliminating RoactCompat","text":"<p>Once you've completed all of the above conversions, you should no longer need to rely on the <code>RoactCompat</code> package in your module. Congratulations, your migration is complete!</p>"},{"location":"migrating-from-legacy/minimum-requirements/","title":"Minimum Requirements","text":"<p>When upgrading to React Lua, a small set of legacy patterns and features need to be fixed in order to maintain intended behavior. Once these conditions are met, your legacy Roact code should work as expected in React Lua.</p> <p>All of these requirements can be met using APIs available in legacy Roact, though most will require a minimum version. This means that a Roact codebase can safely be made compatible with React Lua as a preliminary step before adopting it.</p>"},{"location":"migrating-from-legacy/minimum-requirements/#no-reserved-props","title":"No Reserved Props","text":"<p>In React Lua, components cannot rely on any reserved prop keywords:</p> <ul> <li>\"ref\" - reserved by React to assign refs, equivalent to legacy Roact's <code>Roact.Ref</code></li> <li>\"key\" - reserved by React to assign stable keys to children</li> <li>\"children\" - reserved by React as a special prop representing the children passed down to the component</li> </ul> <p>If your component is using \"ref\" or \"key\" as the name of one of its props, those props will no longer be populated with a value in React Lua.</p> <p>Additionally, if it's using \"children\" as the name of one of its props, the value of the \"children\" prop will become the table of child elements instead of the value provided by the parent component in React Lua.</p> <p>Info</p> <p>This restriction does not involve legacy APIs, so this migration can be completed in codebases depending upon any version of legacy Roact.</p>"},{"location":"migrating-from-legacy/minimum-requirements/#example","title":"Example","text":"<p>Suppose we have a component <code>OptionButton</code> and a separate component <code>ButtonGroup</code> that uses it.</p> <p>The <code>OptionButton</code> component is using a prop called <code>key</code> to pass through to its LayoutOrder. In React Lua, this prop will be nil because it will be consumed by Roact and used as a stable key.</p> <p>To fix this, we replace the use of the <code>key</code> prop with a prop with a different name.</p>"},{"location":"migrating-from-legacy/minimum-requirements/#legacy","title":"Legacy","text":"<pre><code>local function OptionButton(props)\n    return Roact.createElement(\"TextButton\", {\n        LayoutOrder = props.key,\n        Text = props.text,\n        [Roact.Event.Activated] = props.onClick,\n    })\nend\n\nlocal function ButtonGroup(props)\n    return Roact.createFragment({\n        CancelButton = Roact.createElement(OptionButton, {\n            key = 1,\n            text = \"Cancel\",\n            onClick = props.cancelCallback,\n        })\n        ConfirmButton = Roact.createElement(OptionButton, {\n            key = 2,\n            text = \"Confirm\",\n            onClick = props.confirmCallback,\n        })\n    })\nend\n</code></pre>"},{"location":"migrating-from-legacy/minimum-requirements/#react-lua-compatible","title":"React Lua Compatible","text":"<pre><code>local function OptionButton(props)\n    return Roact.createElement(\"TextButton\", {\n        LayoutOrder = props.order,\n        Text = props.text,\n        [Roact.Event.Activated] = props.onClick,\n    })\nend\n\nlocal function ButtonGroup(props)\n    return Roact.createFragment({\n        CancelButton = Roact.createElement(OptionButton, {\n            order = 1,\n            text = \"Cancel\",\n            onClick = props.cancelCallback,\n        })\n        ConfirmButton = Roact.createElement(OptionButton, {\n            order = 2,\n            text = \"Confirm\",\n            onClick = props.confirmCallback,\n        })\n    })\nend\n</code></pre>"},{"location":"migrating-from-legacy/minimum-requirements/#no-legacy-context","title":"No Legacy Context","text":"<p>Legacy Roact implemented a <code>_context</code> field on all component instances as an alternative implementation for the Context feature. This is deprecated in legacy Roact and is not supported in React Lua. Attempting to access fields on <code>self._context</code> in React Lua will throw an error.</p>"},{"location":"migrating-from-legacy/minimum-requirements/#how-to-convert","title":"How To Convert","text":"<p>Replace any uses of <code>_context</code> with the Provider and Consumer pattern via <code>createContext</code>. This is the preferred pattern in legacy Roact as well because it allows Roact to trigger updates on context consumers when context providers pass in a new value.</p> <p>Generally, you'll take the following steps:</p> <ol> <li>Create a context object that you will use in place of <code>_context</code> by calling <code>createContext</code> and saving the result, usually as the return value of a separate <code>ModuleScript</code>.</li> <li>Wherever you have a component that writes to <code>self._context</code>, instead wrap the component's children in a <code>Context.Provider</code> component and provide the value that was previously being written to <code>self._context</code>.</li> <li>Wherever you have a component that reads from <code>self._context</code>, instead wrap that component's children in a <code>Context.Consumer</code> component. The Consumer accepts the <code>render</code> prop, which is a function that accepts a context value and returns a React element.</li> </ol> <p>Info</p> <p>The <code>createContext</code> API is available in legacy Roact 1.3.0 (or newer) and is fully supported in React Lua.</p>"},{"location":"migrating-from-legacy/minimum-requirements/#example_1","title":"Example","text":"<p>Suppose we have a <code>style</code> object that must be provided to all children of our app. We define it in our top-level <code>App</code> component and read from it in our <code>Label</code> component.</p>"},{"location":"migrating-from-legacy/minimum-requirements/#legacy_1","title":"Legacy","text":"<pre><code>local AppStyle = require(script.Parent.AppStyle)\n\nlocal Label = Roact.Component:extend(\"Label\")\n\nfunction Label:init()\n    -- reading style from context\n    self.style = self._context.style\nend\n\nfunction Label:render()\n    return Roact.createElement(\"TextLabel\", {\n        BackgroundColor3 = self.style.LabelColor,\n        Text = props.text,\n    })\nend\n\nlocal App = Roact.Component:extend(\"App\")\n\nfunction App:init()\n    -- defining style in context\n    self._context.style = AppStyle\nend\n\nfunction App:render()\n    return Roact.createElement(\"Frame\", {\n        Size = UDim2.fromScale(1, 1)\n    }, {\n        Start = Roact.createElement(Button, {\n            text = \"Hello World\",\n        })\n    })\nend\n</code></pre>"},{"location":"migrating-from-legacy/minimum-requirements/#react-lua-compatible_1","title":"React Lua Compatible","text":"<pre><code>local AppStyle = require(script.Parent.AppStyle)\n\nlocal StyleContext = Roact.createContext(nil)\n\nlocal Label = Roact.Component:extend(\"Label\")\n\nfunction Label:render()\n    return Roact.createElement(StyleContext.Consumer, {\n        render = function(style)\n            return Roact.createElement(\"TextLabel\", {\n                BackgroundColor3 = style.LabelColor,\n                Text = props.text,\n            })\n        end\n    })\nend\n\nlocal App = Roact.Component:extend(\"App\")\n\nfunction App:render()\n    return Roact.createElement(StyleContext.Provider, {\n        value = AppStyle,\n    }, {\n        App = Roact.createElement(\"Frame\", {\n            Size = UDim2.fromScale(1, 1)\n        }, {\n            Start = Roact.createElement(Button, {\n                text = \"Hello World\",\n            })\n        })\n    })\nend\n</code></pre>"},{"location":"migrating-from-legacy/minimum-requirements/#explicit-ref-forwarding","title":"Explicit Ref Forwarding","text":"<p>Legacy Roact uses <code>Roact.Ref</code> as a special prop key to support the refs feature. Assigning the <code>[Roact.Ref]</code> property to a callback ref or ref object allows Roact to assign its value. However, Roact only interacts with the <code>Roact.Ref</code> property if the component receiving the props is a host component.</p> <p>Some class component definitions rely on this behavior by accepting and reassigning the <code>[Roact.Ref]</code> prop themselves, knowing that Roact won't capture it. The pattern of passing a provided ref onto a child is called \"ref forwarding\". We refer to using <code>[Roact.Ref]</code> as mechanism of ref forwarding as \"implicit ref forwarding\".</p>"},{"location":"migrating-from-legacy/minimum-requirements/#how-to-convert_1","title":"How To Convert","text":"<p>In React Lua, <code>Roact.Ref</code> is aliased to the string \"ref\", and refs that point to class components are now supported. Components that were using implicit ref forwarding will fail to forward their provided refs when upgrading to React Lua.</p> <p>Fortunately, this can be easily fixed with the <code>forwardRef</code> function. We refer to this as \"explicit ref forwarding\".</p> <p>Info</p> <p>The <code>forwardRef</code> API is available in legacy Roact 1.4.0 (or newer) and is fully supported in React Lua.</p>"},{"location":"migrating-from-legacy/minimum-requirements/#example_2","title":"Example","text":"<p>Suppose we have a <code>FancyTextBox</code> component that accepts a ref, and passes it on to an underlying <code>TextBox</code>. Rather than accepting the <code>[Roact.Ref]</code> prop, we should use the <code>Roact.forwardRef</code> wrapper to explicitly accept a ref and assign it to the <code>TextBox</code>.</p>"},{"location":"migrating-from-legacy/minimum-requirements/#legacy_2","title":"Legacy","text":"<pre><code>local function FancyButton(props)\n    return Roact.createElement(\"TextBox\", {\n        PlaceholderText = \"Enter your text here\",\n        PlaceholderColor3 = Color3.new(0.4, 0.4, 0.4),\n        [Roact.Change.Text] = props.onTextChange,\n        -- Implicitly forwarding a ref via the `Roact.Ref` prop\n        [Roact.Ref] = props[Roact.Ref],\n    })\nend\n</code></pre>"},{"location":"migrating-from-legacy/minimum-requirements/#react-lua-compatible_2","title":"React Lua Compatible","text":"<pre><code>local FancyButton = Roact.forwardRef(function(props, ref)\n    return Roact.createElement(\"TextBox\", {\n        PlaceholderText = \"Enter your text here\",\n        PlaceholderColor3 = Color3.new(0.4, 0.4, 0.4),\n        [Roact.Change.Text] = props.onTextChange,\n        -- Explicitly forwarding a ref passed in via `forwardRef`\n        [Roact.Ref] = ref,\n    })\nend)\n</code></pre> <p>You can see a full example of <code>forwardRef</code> migration in this UIBlox PR.</p>"},{"location":"migrating-from-legacy/minimum-requirements/#prefer-getderivedstatefromprops","title":"Prefer getDerivedStateFromProps","text":"<p>Legacy Roact allows class components to implement both <code>willUpdate</code> and <code>getDerivedStateFromProps</code> lifecycle methods.</p> <p>React JS, however, does not support both methods when implemented on the same component. When <code>getDerivedStateFromProps</code> is defined, it replaces <code>componentWillUpdate</code> entirely. React Lua inherits this restriction: <code>getDerivedStateFromProps</code> will replace <code>willUpdate</code> if both are defined.</p>"},{"location":"migrating-from-legacy/minimum-requirements/#how-to-convert_2","title":"How To Convert","text":"<p>In order to make existing components React Lua compatible, make sure to use either <code>willUpdate</code> or <code>getDerivedStateFromProps</code>, but not both.</p> <p>Whenever possible, use <code>getDerivedStateFromProps</code> to resolve interactions between state and props. Just like in React JS 16.3.0 and onward, <code>willUpdate</code> is a deprecated legacy lifecycle method and should be avoided as it can exacerbate problems with asynchronous rendering, a flagship feature of React Lua.</p> <p>Info</p> <p>The <code>getDerivedStateFromProps</code> static lifecycle method is supported in legacy Roact as far back as Roact 0.2.0 and is fully supported in React Lua.</p>"},{"location":"migrating-from-legacy/minimum-requirements/#example_3","title":"Example","text":"<p>Typically, usage of both <code>willUpdate</code> and <code>getDerivedStateFromProps</code> is a sign of an overly complicated component, which makes it difficult to provide a simplified example that's meaningful.</p> <p>Refer to the React JS guidance on migrating away from legacy lifecycle methods.</p>"},{"location":"migrating-from-legacy/upgrading-to-react-lua/","title":"Adding a React Lua Dependency","text":"<p>Warning</p> <p>This page is written for internal Roblox employees, and makes reference in its entirety to internal tools and workflows you likely do not have access to. If you'd like to rewrite this page with installation instructions relevant to Roblox developers, please see this issue.</p> <p>React Lua is available as a collection of packages hosted in the https://github.com/jsdotlua/react-lua repository. Internal Roblox projects use a package manager called Rotriever to resolve and manage dependencies.</p> <p>Info</p> <p>React Lua is a \"package workspace\", meaning that it consists of multiple packages living in the same project. We recommend using Rotriever version 0.5.4 or newer to make sure it has the latest workspace feature support.</p> <p>Refer to Rotriever's documentation for more information on how to install or upgrade your version.</p>"},{"location":"migrating-from-legacy/upgrading-to-react-lua/#new-projects","title":"New Projects","text":"<ol> <li>Make sure you're using rotriever version <code>0.5.4</code> or newer. You can check this by running <code>rotrieve -V</code>.</li> <li>Add the following to your <code>rotriever.toml</code> manifest file:     <pre><code>[dependencies]\nReact = \"github.com/roblox/roact-alignment@17.0.1\"\nReactRoblox = \"github.com/roblox/roact-alignment@17.0.1\"\n</code></pre></li> <li>Run <code>rotrieve install</code> to install all dependencies</li> <li><code>React.lua</code> and <code>ReactRoblox.lua</code> will be added to the <code>Packages</code> folder generated by rotriever in your project. Make sure this folder is included in your project when testing with <code>roblox-cli</code> or Roblox Studio.</li> </ol>"},{"location":"migrating-from-legacy/upgrading-to-react-lua/#replacing-legacy-roact","title":"Replacing Legacy Roact","text":"<p>The easiest way to adopt React Lua in an existing Roact project is to change your existing dependency on legacy Roact.</p> <p>Make the following changes to your <code>rotriever.toml</code> manifest file: <pre><code>[dependencies]\n- Roact = \"github.com/roblox/roact@1.4\"\n+ Roact = { target = \"github.com/roblox/roact-alignment\", version = \"17.0.1\", package = \"RoactCompat\" }\n</code></pre></p> <p>This creates a dependency on the <code>RoactCompat</code> package, which provides a compatibility layer for migrating from legacy APIs.</p> <p>Since it's still named <code>Roact</code> in the above snippet, it will be aliased to <code>Roact</code> in your code. If your code meets the minimum requirements, this dependency change will upgrade your project to React Lua without requiring any further changes to your source code.</p>"},{"location":"migrating-from-legacy/upgrading-to-react-lua/#accessing-new-features","title":"Accessing New Features","text":"<p>However, the <code>RoactCompat</code> API only covers enough to provide backwards compatibility. To access new features like hooks or suspense, you will need to add dependencies on <code>React</code> and <code>ReactRoblox</code> as well: <pre><code>[dependencies]\nRoact = { target = \"github.com/roblox/roact-alignment\", version = \"17.0.1\", package = \"RoactCompat\" }\nReact = \"github.com/roblox/roact-alignment@17.0.1\"\nReactRoblox = \"github.com/roblox/roact-alignment@17.0.1\"\n</code></pre></p> <p>The <code>RoactCompat</code> package can be safely mixed and matched with the new <code>React</code> and <code>ReactRoblox</code> packages; it's nothing more than a thin wrapper around them that aligns with the legacy Roact API and semantics.</p> <p>Info</p> <p>Since we're not using an alias for the <code>React</code> and <code>ReactRoblox</code> packages, we can define our dependencies using the shorthand format. Read up on specifying Rotriever dependencies for more information.</p>"},{"location":"migrating-from-legacy/upgrading-to-react-lua/#patching-other-dependencies","title":"Patching Other Dependencies","text":"<p>You may need to additionally account for other dependencies in your project that use Roact. If you depend on a package that has its own dependency on legacy Roact, you may need to use rotriever's <code>patch</code> feature to replace the legacy version throughout the tree.</p> <p>You might encounter this if you have existing dependencies on any of the following:</p> <ul> <li>InfiniteScroller (compatible with React Lua from version 0.8.0 onwards)</li> <li>RoactFitComponents (compatible with React Lua from version 2.0.0 onwards)</li> <li>RoactRodux (compatible with React Lua from version 0.4.1 onwards)</li> <li>UIBlox (compatible with React Lua on the latest master)</li> <li>Numerous other projects that depend on legacy Roact, especially if they're older than the latest version</li> </ul> <p>To resolve this, you can patch over any dependencies on legacy Roact and align them with your newly-added version. Add this additional section to your <code>rotriever.toml</code> manifest file: <pre><code>[config.patch.\"github.com/roblox/roact\"]\nRoact = { target = \"github.com/roblox/roact-alignment\", version = \"17.0.1\", package = \"RoactCompat\" }\n</code></pre></p> <p>To learn more about patching dependencies, check out the Rotriever documentation.</p> <p>Caution</p> <p>When you're patching over Roact, make sure your other dependencies are compatible with React Lua. You may need to upgrade them to more recent versions so that they comply with the React Lua requirements.</p>"},{"location":"migrating-from-legacy/upgrading-to-react-lua/#testing-with-both","title":"Testing with Both","text":"<p>In some cases, you may not yet be equipped to safely adopt React Lua, but you want to begin adopting it in tests or storybooks so your project can enforce compatibility.</p> <p>One reasonable way to accomplish this is to depend on both projects, but to conditionally swap in React Lua at runtime. To do this, make sure your <code>rotriever.toml</code> manifest file contains the following: <pre><code>[dependencies]\nRoact = \"github.com/roblox/roact@1.4\"\n\n[dev_dependencies]\nRoactCompat = \"github.com/roblox/roact-alignment@17.0.1\"\n</code></pre></p> <p>This declares a dependency on legacy Roact as well as a dev dependency on React Lua.</p> <p>In your test runner script or other equivalent entry point, check the value of a global (or flag, or any other preferred configuration method), and overwrite the <code>Roact</code> API with that of <code>RoactCompat</code> when enabled. It may look something like this:</p> <pre><code>if _G.__NEW_ROACT__ then\n    local Roact = require(Packages.Roact)\n    local RoactCompat = require(Packages.Dev.RoactCompat)\n\n    -- Overwrite the contents of the `Roact` package with that of the\n    -- RoactCompat package\n    for api, _ in Roact do\n        Roact[api] = RoactCompat[api]\n    end\nend\n\n-- Proceed with test setup...\n</code></pre> <p>In the above example, an additional test suite can be created for use with <code>lest</code> or via a <code>robloxdev-cli</code> command line invocation that sets the <code>__NEW_ROACT__</code> global to <code>true</code>.</p> <p>To see this technique in action, you can find a comprehensive example in this PR to the UIBlox library.</p>"}]}