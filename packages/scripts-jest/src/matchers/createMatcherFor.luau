-- Lua upstream https://github.com/facebook/react/blob/6d50a9d090a2a672fc3dea5ce77a3a05332a6caa/scripts/jest/matchers/toWarnDev.js
-- Lua deviation: extract this so we can consolidate the Lua console testing specifics in one place
-- Lua TODO: upstream puts this all in one file, and then has fragmented ways to test for console.warn/error/log output
--!strict
local __DEV__ = _G.__DEV__
local shouldIgnoreConsoleError = require(script.Parent.Parent.shouldIgnoreConsoleError)

local function normalizeCodeLocInfo(str)
	if type(str) ~= "string" then
		return str
	end

	-- This special case exists only for the special source location in
	-- ReactElementValidator. That will go away if we remove source locations.
	str = str:gsub("Check your code at .*:%d+", "Check your code at **")
	-- V8 format:
	--  at Component (/path/filename.js:123:45)
	-- React format:
	--    in Component (at filename.js:123)

	-- Lua deviation: In lua, stack frames are like this:
	-- in Component (at Workspace/Packages/FileName.lua:31337)
	return (str:gsub("\n    in ([%w%-%._]+)[^\n]*", "\n    in %1 (at **)"))
end

return function(consoleMethod, matcherName)
	-- Lua deviation: additional first self param, extra ... to test for arity
	return function(_matcherContext, callback, expectedMessages, options, ...)
		-- Lua note: require is here on purpose, console isn't a built-in like in JS
		local LuauPolyfill = require(Packages.LuauPolyfill)
		local Array = LuauPolyfill.Array
		local console = LuauPolyfill.console

		if options == nil then
			options = {}
		end
		if __DEV__ then
			-- Warn about incorrect usage of matcher.
			if type(expectedMessages) == "string" then
				expectedMessages = { expectedMessages }
			elseif not Array.isArray(expectedMessages) then
				error(
					`{matcherName}() requires a parameter of type string or an array of strings `
						.. `but was given {typeof(expectedMessages)})`
				)
			end
			-- Lua deviation: since an empty table will return true for `Array.isArray(options)`
			-- check if the table is not empty as well, this is required for tests to pass
			if type(options) ~= "table" or (Array.isArray(options) and next(options) ~= nil) then
				error(
					`{matcherName}() second argument, when present, should be an object. `
						.. "Did you forget to wrap the messages into an array?"
				)
			end
			if select("#", ...) > 0 then
				-- `matcher` comes from Jest, so it's more than 2 in practice
				error(
					`{matcherName}() received more than two arguments. `
						.. "Did you forget to wrap the messages into an array?"
				)
			end

			local withoutStack = options.withoutStack
			local logAllErrors = options.logAllErrors
			local warningsWithoutComponentStack = {}
			local warningsWithComponentStack = {}
			local unexpectedWarnings = {}

			local lastWarningWithMismatchingFormat = nil
			local lastWarningWithExtraComponentStack = nil

			-- Catch errors thrown by the callback,
			-- But only rethrow them if all test expectations have been satisfied.
			-- Otherwise an Error in the callback can mask a failed expectation,
			-- and result in a test that passes when it shouldn't.
			local caughtError

			local function isLikelyAComponentStack(message)
				return type(message) == "string"
					and (string.match(message, "\n    in ") ~= nil or string.match(message, "\n    at ") ~= nil)
			end

			local function consoleSpy(format, ...)
				-- Ignore uncaught errors reported by jsdom
				-- and React addendums because they're too noisy.
				local args = { ... }
				if not logAllErrors and consoleMethod == "error" and shouldIgnoreConsoleError(format, args) then
					return
				end

				-- Lua deviation BEGIN: upstream uses a tiny external util package, here we inline making format more durable
				local message = format
				local formattedOk, formattedOrError = pcall(string.format, format, unpack(args))
				if formattedOk then
					message = formattedOrError
				end
				-- Lua deviation END
				local normalizedMessage = normalizeCodeLocInfo(message)

				-- Remember if the number of %s interpolations
				-- doesn't match the number of arguments.
				-- We'll fail the test if it happens.
				local argIndex = 0
				format:gsub("%%s", function()
					argIndex += 1
					return argIndex - 1
				end)
				-- Lua deviation: lua needs a secondary way to detect mismatches due to format errors
				if not formattedOk or argIndex ~= #args then
					lastWarningWithMismatchingFormat = {
						format = format,
						args = args,
						expectedArgCount = argIndex,
					}
				end

				-- Protect against accidentally passing a component stack
				-- to warning() which already injects the component stack.
				if #args >= 2 and isLikelyAComponentStack(args[#args]) and isLikelyAComponentStack(args[#args - 1]) then
					lastWarningWithExtraComponentStack = { format = format }
				end

				for index = 1, #expectedMessages do
					local expectedMessage = expectedMessages[index]
					if
						normalizedMessage == expectedMessage
						or normalizedMessage:find(expectedMessage, 1, true) ~= nil
					then
						if isLikelyAComponentStack(normalizedMessage) then
							table.insert(warningsWithComponentStack, normalizedMessage)
						else
							table.insert(warningsWithoutComponentStack, normalizedMessage)
						end
						Array.splice(expectedMessages, index, 1)
						return
					end
				end

				local errorMessage
				if #expectedMessages == 0 then
					errorMessage = "Unexpected warning recorded: " .. normalizedMessage
				elseif #expectedMessages == 1 then
					errorMessage = "Unexpected warning recorded: "
						.. tostring(JestDiff.diff(expectedMessages[1], normalizedMessage))
				else
					errorMessage = "Unexpected warning recorded: "
						.. tostring(JestDiff.diff(expectedMessages, { normalizedMessage }))
				end

				-- Record the call stack for unexpected warnings.
				-- We don't throw an Error here though,
				-- Because it might be suppressed by ReactFiberScheduler.
				table.insert(unexpectedWarnings, Error.new(errorMessage))
			end

			-- TODO Decide whether we need to support nested toWarn* expectations.
			-- If we don't need it, add a check here to see if this is already our spy,
			-- And throw an error.
			local originalMethod = console[consoleMethod]

			-- Avoid using Jest's built-in spy since it can't be removed.
			console[consoleMethod] = consoleSpy

			local ok, error_ = pcall(callback)
			if not ok then
				caughtError = error_
			end

			-- Lua note: finally block
			-- Restore the unspied method so that unexpected errors fail tests.
			console[consoleMethod] = originalMethod

			-- Any unexpected Errors thrown by the callback should fail the test.
			-- This should take precedence since unexpected errors could block warnings.
			if caughtError then
				-- Lua note: specific second argument tuned based on React's test suite needs
				error(caughtError, 4)
			end

			-- Any unexpected warnings should be treated as a failure.
			if #unexpectedWarnings > 0 then
				return {
					message = function()
						return unexpectedWarnings[1].stack
					end,
					pass = false,
				}
			end

			-- Any remaining messages indicate a failed expectations.
			if #expectedMessages > 0 then
				return {
					message = function()
						return string.format(`Expected warning was not recorded:\n  {expectedMessages[1]}`)
					end,
					pass = false,
				}
			end

			if type(withoutStack) == "number" then
				-- We're expecting a particular number of warnings without stacks.
				if withoutStack ~= #warningsWithoutComponentStack then
					return {
						message = function()
							return `Expected {withoutStack} warnings without a component stack but received {#warningsWithoutComponentStack}:\n`
								.. table.concat(warningsWithoutComponentStack, "\n")
						end,
						pass = false,
					}
				end
			elseif withoutStack == true then
				-- We're expecting that all warnings won't have the stack.
				-- If some warnings have it, it's an error.
				if #warningsWithComponentStack > 0 then
					return {
						message = function()
							return `Received warning unexpectedly includes a component stack:\n  {warningsWithComponentStack[1]}`
								.. "\nIf this warning intentionally includes the component stack, remove "
								.. `\{withoutStack = true\} from the {matcherName}() call. If you have a mix of `
								.. `warnings with and without stack in one {matcherName}() call, pass `
								.. "{withoutStack: N} where N is the number of warnings without stacks."
						end,
						pass = false,
					}
				end
			elseif withoutStack == false or withoutStack == nil then
				-- We're expecting that all warnings *do* have the stack (default).
				-- If some warnings don't have it, it's an error.
				if #warningsWithoutComponentStack > 0 then
					return {
						message = function()
							return `Received warning unexpectedly does not include a component stack:\n  {warningsWithoutComponentStack[1]}`
								.. "\nIf this warning intentionally omits the component stack, add "
								.. `\{withoutStack = true\} to the {matcherName} call.`
						end,
						pass = false,
					}
				end
			else
				error(
					Error.new(
						`The second argument for {matcherName}(), when specified, must be an object. It may have a `
							.. 'property called "withoutStack" whose value may be undefined, boolean, or a number. '
							.. `Instead received {typeof(withoutStack)}.`
					)
				)
			end

			if lastWarningWithMismatchingFormat ~= nil then
				return {
					message = function()
						return `Received {#lastWarningWithMismatchingFormat.args} arguments for a message with {lastWarningWithMismatchingFormat.expectedArgCount} placeholders:\n  {lastWarningWithMismatchingFormat.format}`
					end,
					pass = false,
				}
			end
			if lastWarningWithExtraComponentStack ~= nil then
				return {
					message = function()
						return `Received more than one component stack for a warning:\n  {lastWarningWithExtraComponentStack.format}`
							.. "\nDid you accidentally pass a stack to warning() as the last argument? "
							.. "Don't forget warning() already injects the component stack automatically."
					end,
					pass = false,
				}
			end

			return { pass = true }
		else
			-- Any uncaught errors or warnings should fail tests in production mode.
			callback()

			return { pass = true }
		end
	end
end
